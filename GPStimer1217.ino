#include <U8g2lib.h>
#include <Wire.h>
#include <TinyGPS++.h>
#include <SD.h>
#include <SPI.h>
#include <math.h>
#include <WiFi.h>
#include <WebServer.h>
#include <Update.h>
// #include <ESPmDNS.h>
//#include <WiFiManager.h>

WebServer server(80);

// WiFiManager wifiManager;
// WiFiManager で取得したSSID/PASSWORDを変数に格納
// String connectedSSID = WiFi.SSID();
// String connectedPASS = WiFi.psk();

bool serverStarted = false;
//String selectedSSID = "";
//String password = "";
bool wifiConnected = false;
bool cancelWiFi = false;
int selectgps = 0;
bool selectGPS = false;

// ---------- GPS ----------
TinyGPSPlus gps;
HardwareSerial ss(1);  // Serial1 を使用
#define RX_PIN 16      // GPS TX -> ESP32 RX1
#define TX_PIN 17      // GPS RX -> ESP32 TX1

//SD記録
unsigned long lastGPSMillis = 0;  // GPS 1Hz記録用
File lapFile;
File gpsFile;
SPIClass spiHSPI(HSPI);
#define HSPI_SCK  14
#define HSPI_MISO 12
#define HSPI_MOSI 13
#define HSPI_CS 15

// LCD (ST75256 WO256x128) VSPI用ピン
#define LCD_CS  5
#define LCD_DC  2
#define LCD_RST 4
// SPI用st75256
U8G2_ST75256_JLX256128_F_4W_HW_SPI u8g2(
  U8G2_R0,    // 回転
  LCD_CS,
  LCD_DC,
  LCD_RST
);

// ボタン
#define BTN_LEFT 32
#define BTN_RIGHT 33
#define BTN_SELECT 25
#define BTN_BACK 26

unsigned long lastButtonPress = 0;
const unsigned long debounceTime = 200;  // 200ms デバウンス
// 選択中のアイコン
int selected = 0;
int startIndex = 0;  // 画面に表示する最初のアイコン番号
const int iconCount = 6;

//ログファイル一覧管理
String fileList[99];
int fileCount = 0;

String folderList[99];
int folderCount = 0;

String laps[50];
int lapCount = 0;

// フォルダ選択用
int folderIndex = 0;   // 現在選択しているフォルダ番号
int folderScroll = 0;  // フォルダリストのスクロール位置

// ファイル選択用
int fileIndex = 0;   // 現在選択しているファイル番号
int fileScroll = 0;  // ファイルリストのスクロール位置

// CSVラップ選択用
int csvIndex = 0;   // 現在選択しているラップ番号
int csvScroll = 0;  // CSVのスクロール位置

// 表示する行数（共通）
const int DISPLAY_LINES = 7;

//ファイル・フォルダー更新用判断
static bool recordfolder = false;
static bool recordfile = false;
static bool recordcsv = false;

//設定
static int contrast = 120;  //明るさ

//タイムレコーダー
int selectTimer = 0;
int lap = 0;
long lapTimes[256];
bool running = false;
unsigned long lapStart = 0;
unsigned long lapTime = 0;
long gap = 0;
unsigned long lastLapDisplayTime = 0;  // 最後にラップを検出した時刻
unsigned long gpxrecord = 0;
bool showLapTime = false;              // 固定表示中フラグ
unsigned long lastLapDuration = 0;     // 固定表示用に保存するラップタイム
int laptimeDisplay = 5000; //ラップタイムを表示する時間
unsigned long bestTime = 999999;
String lapcurrentFolder = "";  // 初回測定時に作成するフォルダパス
String gpscurrentFolder = "";
String lapFileName = "";
String gpsFileName = "";

//GPSタイムボタン(二点の座標を決めて記録線を決める)
double lineLat1 = 35.435729, lineLon1 = 139.961575;
double lineLat2 = 35.435760, lineLon2 = 139.961648;
String nowcircuit = "設定されていません";
double currLat = 0, currLon = 0;
double prevLat = 0, prevLon = 0;

//トラック画面の関数
int selectTrack = 0;//トラック画面の選択用
String circuits[100][8];
int Csvnum = 0; //ベストタイムのトラック用
int Csvbesttime = 0;
int circuitCount = 0;//読み込んだサーキットの数（配列のヘッダを除く列の数）
int circuitIndex = 0;//選択スクロール用
bool viewstate = false;
int viewstateframe = 0;//詳細選択画面用
bool showMessage = false; 
bool showdetail = false;
bool showdeleat = false;
bool firstpoint = false;
double LAT1 = 000.000000;
double LON1 = 000.000000;
double LAT2 = 000.000000;
double LON2 = 000.000000;

//wifi画面の関数
String SSIDPAS[2];

//オープニングイラスト
const uint8_t openning[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 
  0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xF8, 0xFF, 0x07, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 
  0xFF, 0x7F, 0xC0, 0xC1, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x87, 
  0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x0F, 0xFE, 0x7F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x3F, 0x00, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 
  0xF8, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x00, 0xF8, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0x3F, 0xFC, 0x07, 0x00, 
  0xF0, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xF8, 0xFF, 0xFF, 0xFF, 0x07, 0xE0, 0x0F, 0x00, 0x00, 0xE0, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 
  0x03, 0x80, 0x3F, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x01, 0x00, 0x7E, 0x00, 
  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xF8, 0x03, 0x00, 0x7F, 0xF8, 0xE1, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 
  0x0F, 0xFF, 0xF0, 0xFF, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x30, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x00, 
  0x7F, 0xFC, 0xE1, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0x0F, 0xFF, 0xC3, 0x7F, 
  0x00, 0x00, 0xF8, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0x80, 0x3F, 0xF8, 0xE1, 0xFF, 
  0xFF, 0x03, 0xFF, 0xFF, 0x0F, 0xFF, 0x07, 0x3C, 0x00, 0x00, 0xF0, 0x01, 
  0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xE0, 0x0F, 0x80, 0x3F, 0xF8, 0xE1, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 
  0x07, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x0C, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x0F, 0x80, 
  0x1F, 0xF8, 0xE1, 0x0F, 0xF0, 0x0F, 0x3F, 0x00, 0x00, 0x3F, 0x80, 0x01, 
  0x00, 0x00, 0xC0, 0x03, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x1F, 0xC0, 0x1F, 0xF8, 0xE1, 0x0F, 
  0xE0, 0x0F, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x1F, 0x00, 0x00, 0x80, 0x07, 
  0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0x1F, 0xC0, 0x0F, 0xF8, 0xE1, 0x0F, 0xC0, 0x0F, 0x3F, 0x00, 
  0x00, 0x3F, 0x00, 0x3F, 0x00, 0x00, 0x80, 0x07, 0x0C, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0xE0, 
  0x0F, 0xF8, 0xE1, 0x0F, 0xC0, 0x0F, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x3F, 
  0x00, 0x00, 0x00, 0x0F, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0xE0, 0x07, 0xF8, 0xE1, 0x0F, 
  0xE0, 0x0F, 0xFF, 0xFF, 0x03, 0x3F, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x1E, 
  0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3F, 0xF0, 0x07, 0xF8, 0xE1, 0x0F, 0xF0, 0x0F, 0xFF, 0xFF, 
  0x03, 0x3F, 0xC0, 0x3F, 0x00, 0x00, 0x00, 0x1E, 0x30, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xF0, 
  0x03, 0xF8, 0xE1, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0x1F, 
  0x00, 0x00, 0x00, 0x3C, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xF0, 0x03, 0xF8, 0xE1, 0xFF, 
  0xFF, 0x03, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x78, 
  0xC0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0xF8, 0x03, 0xF8, 0xE1, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 
  0x03, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xF0, 0x81, 0x03, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xF8, 
  0x01, 0xF8, 0xE1, 0xFF, 0x7F, 0x00, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0x01, 
  0x00, 0x00, 0x00, 0xE0, 0x1F, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFD, 0x01, 0xF8, 0xE1, 0x0F, 
  0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0xF8, 0x03, 0x00, 0x00, 0x00, 0x80, 
  0x0F, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xF8, 0xFD, 0x00, 0xF8, 0xE1, 0x0F, 0x00, 0x00, 0x3F, 0x00, 
  0x00, 0x3F, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 
  0x00, 0xF8, 0xE1, 0x0F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0xF0, 0x07, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F, 0x00, 0xF8, 0xE1, 0x0F, 
  0x00, 0x00, 0x7F, 0x00, 0x00, 0x3F, 0xE0, 0x0F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xE0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xF0, 0x7F, 0x00, 0xF8, 0xE1, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 
  0x0F, 0x3F, 0xC0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F, 
  0x00, 0xFC, 0xE1, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x3F, 0x80, 0x3F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x3F, 0x00, 0xFC, 0xE1, 0x0F, 
  0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x3F, 0x80, 0x7F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC0, 0x1F, 0x00, 0xF8, 0xC0, 0x07, 0x00, 0x00, 0xFF, 0xFF, 
  0x07, 0x3F, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x0C, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x80, 0xFB, 0xC0, 0x1D, 0xFC, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0xFF, 0xC3, 0x1F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x87, 0xC7, 0x87, 0x87, 
  0x07, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xC0, 0x03, 0xC7, 0x83, 0x03, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0x03, 0xCF, 0xC1, 0x03, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0xCF, 0xC1, 0x03, 
  0x0F, 0x00, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xC0, 0x03, 0xC7, 0xC1, 0x03, 0x07, 0x00, 0x00, 0x00, 
  0xE0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0x87, 0xC7, 0x81, 0x87, 0x07, 0x00, 0x00, 0x00, 0xFC, 0x01, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xC7, 0x81, 0xFF, 
  0x03, 0x00, 0x00, 0x80, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xC0, 0xFF, 0xC1, 0x01, 0xFE, 0x01, 0x00, 0x00, 0xF8, 
  0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0x23, 0x00, 0x00, 0x30, 0x00, 0x00, 0xC0, 0xFF, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFC, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x1F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xF0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00,
};

// ストップウォッチイラスト
const uint8_t icon0[] PROGMEM = {
  0x00, 0x00, 0xFE, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x7F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
  0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xFE, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xF8, 0x1F, 0x00, 0x0F, 0x00, 0x00, 0x80, 0xFF, 0xFF, 
  0x01, 0x1F, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0x07, 0x3F, 0x00, 0x00, 0xF8, 
  0xFF, 0xFF, 0x1F, 0x7F, 0x00, 0x00, 0xFE, 0xCF, 0xF1, 0x3F, 0xFC, 0x00, 
  0x00, 0xFF, 0xC0, 0x81, 0xFF, 0xF8, 0x01, 0x80, 0x3F, 0xC0, 0x01, 0xFE, 
  0xF1, 0x03, 0xC0, 0x0F, 0x80, 0x00, 0xF8, 0xE3, 0x03, 0xE0, 0x0F, 0x00, 
  0x00, 0xF0, 0xC7, 0x01, 0xF0, 0x0F, 0x00, 0x00, 0xF8, 0x07, 0x00, 0xF8, 
  0x1D, 0x00, 0x00, 0xFC, 0x0F, 0x00, 0xF8, 0x18, 0x80, 0x00, 0x9C, 0x1F, 
  0x00, 0x7C, 0x00, 0x80, 0x01, 0x00, 0x1F, 0x00, 0x7C, 0x00, 0x80, 0x01, 
  0x00, 0x3E, 0x00, 0x3E, 0x00, 0xC0, 0x01, 0x00, 0x3E, 0x00, 0x3E, 0x00, 
  0xC0, 0x01, 0x00, 0x7C, 0x00, 0x1E, 0x00, 0xC0, 0x03, 0x00, 0x7C, 0x00, 
  0x1F, 0x00, 0x40, 0x00, 0x00, 0x7C, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
  0x78, 0x00, 0x1F, 0x00, 0xC0, 0x03, 0x00, 0x78, 0x00, 0xFF, 0x00, 0xE0, 
  0x07, 0x00, 0x78, 0x00, 0xFF, 0x00, 0xE0, 0x07, 0x80, 0x7F, 0x00, 0x1F, 
  0x00, 0xE0, 0x07, 0x80, 0x7F, 0x00, 0x1F, 0x00, 0xC0, 0x03, 0x00, 0x78, 
  0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x1F, 0x00, 0x00, 0x00, 
  0x00, 0x7C, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x3E, 0x00, 
  0x00, 0x00, 0x00, 0x7C, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 
  0x7C, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x1F, 0x00, 0xF8, 0x1C, 0x00, 0x00, 0x8C, 0x1F, 0x00, 0xF8, 0x1F, 0x00, 
  0x00, 0x9C, 0x0F, 0x00, 0xF0, 0x07, 0x00, 0x00, 0xFC, 0x07, 0x00, 0xE0, 
  0x07, 0x00, 0x00, 0xF8, 0x07, 0x00, 0xC0, 0x0F, 0xC0, 0x00, 0xF8, 0x03, 
  0x00, 0x80, 0x3F, 0xC0, 0x00, 0xFE, 0x01, 0x00, 0x00, 0xFF, 0xC0, 0x80, 
  0xFF, 0x00, 0x00, 0x00, 0xFE, 0xCF, 0xF1, 0x3F, 0x00, 0x00, 0x00, 0xF8, 
  0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0x07, 0x00, 0x00, 
  0x00, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x1F, 0x00, 
  0x00, 0x00,
};

// 記録イラスト
const uint8_t icon1[] PROGMEM = {
  0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xC1, 0x7F, 0x00, 0x00, 0x00, 0x00, 0xFF, 
  0xC1, 0x7F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC1, 0x7F, 0x00, 0x00, 0x00, 
  0x00, 0xFF, 0xC1, 0x7F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC1, 0x7F, 0x00, 
  0x00, 0x00, 0x00, 0xFF, 0xC1, 0x7F, 0x00, 0x00, 0xFE, 0x03, 0xFF, 0xC1, 
  0x7F, 0x00, 0x00, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0x00, 0x00, 0xFE, 0x03, 
  0xFF, 0xC1, 0x7F, 0x00, 0x00, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0x00, 0x00, 
  0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0x00, 0x00, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 
  0x00, 0x00, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0x00, 0x00, 0xFE, 0x03, 0xFF, 
  0xC1, 0x7F, 0x00, 0x00, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF0, 0x0F, 0xFE, 
  0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 
  0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 
  0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 
  0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 
  0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 
  0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 
  0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 
  0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 
  0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 
  0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 
  0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 0xFE, 0x03, 0xFF, 0xC1, 0x7F, 0xF8, 0x0F, 
  0xFE, 0x03,
};

// トラックイラスト
const uint8_t icon2[] PROGMEM = {
  0x00, 0x00, 0x00, 0xE0, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 
  0x0F, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x80, 
  0x1F, 0x00, 0x7C, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x70, 0x00, 0x00, 
  0x0F, 0xE0, 0x01, 0x00, 0x70, 0x00, 0xC0, 0x3F, 0xE0, 0x00, 0x00, 0x70, 
  0x00, 0xF0, 0x7F, 0x70, 0x00, 0x00, 0x70, 0x00, 0xF8, 0xF0, 0x70, 0x00, 
  0x00, 0x70, 0x00, 0x38, 0xE0, 0x70, 0x00, 0x00, 0x38, 0x00, 0x1C, 0xE0, 
  0x38, 0x00, 0x00, 0x1C, 0x00, 0x1C, 0xE0, 0x38, 0x00, 0x00, 0x1E, 0x00, 
  0x0E, 0xE0, 0x38, 0x00, 0x00, 0x0F, 0x00, 0x0E, 0xE0, 0x38, 0x00, 0x80, 
  0x07, 0x00, 0x0E, 0xE0, 0x38, 0x00, 0x80, 0x03, 0x00, 0x06, 0xE0, 0x38, 
  0x00, 0xC0, 0x01, 0x00, 0x07, 0x60, 0x38, 0x00, 0xE0, 0x00, 0x00, 0x07, 
  0x70, 0x38, 0x00, 0xF0, 0x00, 0x00, 0x07, 0x70, 0x38, 0x80, 0x70, 0x00, 
  0x00, 0x07, 0x70, 0x38, 0xC0, 0x33, 0x00, 0x00, 0x07, 0x30, 0x38, 0xC0, 
  0x07, 0x00, 0x00, 0x07, 0x38, 0x38, 0xC0, 0x0F, 0x00, 0x00, 0x07, 0x38, 
  0x38, 0x00, 0x3F, 0x00, 0x00, 0x07, 0x38, 0x38, 0x00, 0x3E, 0x00, 0x00, 
  0x07, 0x38, 0x38, 0xC0, 0x3C, 0x00, 0x00, 0x07, 0x30, 0x38, 0xC0, 0x01, 
  0x00, 0x00, 0x07, 0x70, 0x1C, 0xE0, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x1F, 
  0x70, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x0F, 0x78, 0x08, 0x00, 0x00, 0x07, 
  0x00, 0x03, 0x3C, 0x3C, 0x00, 0x00, 0x07, 0x00, 0x00, 0x1C, 0xCC, 0x07, 
  0x02, 0x07, 0x00, 0x00, 0x0E, 0x8C, 0xFF, 0x03, 0x0E, 0x7E, 0x00, 0x07, 
  0xFE, 0xE3, 0x03, 0xFE, 0xFF, 0x81, 0x07, 0x3E, 0xE6, 0x01, 0xFC, 0xE7, 
  0xC3, 0x03, 0x3E, 0x1E, 0x01, 0xE0, 0x80, 0xFF, 0x01, 0xC6, 0x1F, 0x01, 
  0x00, 0x00, 0xFF, 0x00, 0xE7, 0xF1, 0x01, 0x00, 0x00, 0x18, 0x00, 0x1F, 
  0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x8F, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xFF, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x7E, 0x00, 0x00, 
  0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 
  0x00, 0x00,
};

//gpsイラスト
const uint8_t icon3[] PROGMEM = {
  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x01, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x9C, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x3C, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x7C, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x98, 0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0xC0, 
  0x93, 0x03, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC7, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0xC7, 0x47, 0x00, 0x00, 0x00, 0x00, 0x80, 0x93, 0xE7, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x39, 0xF3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x7C, 
  0xF8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xFC, 0x07, 0x00, 0x00, 0x00, 
  0x00, 0x78, 0xFE, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x30, 0xFF, 0x1F, 0x00, 
  0x00, 0x00, 0x00, 0x80, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 
  0x1F, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
  0xE0, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x23, 0x00, 0x00, 
  0x00, 0x80, 0xC7, 0xFF, 0x71, 0x00, 0x00, 0x00, 0x00, 0x9F, 0xFF, 0xF9, 
  0x00, 0x00, 0x00, 0x00, 0x3E, 0xFF, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x7C, 
  0x7E, 0xF6, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x3C, 0x6F, 0x06, 0x00, 0x00, 
  0x00, 0xF0, 0x99, 0x1F, 0x0F, 0x00, 0x00, 0x00, 0xEC, 0x01, 0x9F, 0x1F, 
  0x00, 0x00, 0x00, 0xDC, 0x03, 0x4E, 0x1F, 0x00, 0x00, 0x00, 0x80, 0x03, 
  0xE4, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0xE1, 0x00, 0x00, 0x01, 
  0x00, 0x02, 0xF0, 0xF1, 0x01, 0x87, 0x03, 0x00, 0x00, 0xE0, 0xF1, 0x03, 
  0x87, 0x07, 0x00, 0x00, 0xC0, 0xEC, 0x01, 0x0F, 0x07, 0x00, 0x00, 0x00, 
  0xDE, 0x00, 0x0E, 0x0F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x0E, 0x3E, 0x00, 
  0x00, 0x00, 0x3E, 0x00, 0x1C, 0xFC, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x3C, 
  0xF8, 0x00, 0x00, 0x00, 0x08, 0x00, 0x78, 0xE0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
  0x00, 0x00,
};

//wifiイラスト
const uint8_t icon4[] PROGMEM = {
  0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0xE0, 
  0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 
  0x00, 0xF8, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x1F, 0x00, 
  0x00, 0x00, 0xC0, 0xFD, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 
  0x3F, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFE, 
  0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x03, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xC0, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x07, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xC0, 
  0xFF, 0x1F, 0xE0, 0xFF, 0x0F, 0x00, 0xC0, 0xFF, 0x1F, 0xE0, 0xFF, 0x1F, 
  0x00, 0xC0, 0xFF, 0x1F, 0xE0, 0xFF, 0x1F, 0x00, 0xE0, 0xFF, 0x1F, 0xE0, 
  0xFF, 0x1F, 0x00, 0xE0, 0xFF, 0x1F, 0xE0, 0xFF, 0x1F, 0x00, 0xF0, 0xFF, 
  0x1F, 0xE0, 0xFF, 0x3F, 0x00, 0xF8, 0xFF, 0x1F, 0xE0, 0xFF, 0x7F, 0x00, 
  0xF8, 0xFF, 0x1F, 0xE0, 0xFF, 0x7F, 0x00, 0xFC, 0xFF, 0x1F, 0xE0, 0xFF, 
  0xFF, 0x00, 0xFC, 0xFF, 0x1F, 0xE0, 0xFF, 0xFF, 0x00, 0xFE, 0xFF, 0x1F, 
  0xE0, 0xFF, 0xFF, 0x01, 0xFE, 0xFF, 0x1F, 0xE0, 0xFF, 0xFF, 0x01, 0xFE, 
  0xFF, 0x1F, 0xE0, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0x1F, 0xE0, 0xFF, 0xFF, 
  0x03, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0x03, 0x00, 
  0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0x07, 0x80, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 
  0x0F, 0xC0, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0x1F, 0xE0, 0xFF, 0xFF, 0x03, 
  0xFF, 0xFF, 0x1F, 0xE0, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0x3F, 0xF0, 0xFF, 
  0xFF, 0x03, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0x03, 0xFE, 0xFF, 0x7F, 
  0xF8, 0xFF, 0xFF, 0x01, 0xFE, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0x01, 0xFE, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x7F, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xF0, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 
  0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x03, 0x00,
};

//設定イラスト
const uint8_t icon5[] PROGMEM = {
  0x00, 0x00, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 
  0x7F, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0xF0, 0x60, 0x00, 0x00, 0x00, 
  0x7E, 0x3C, 0xF0, 0xF8, 0x01, 0x00, 0x00, 0xFF, 0x3C, 0xF0, 0xFC, 0x03, 
  0x00, 0x80, 0xFF, 0x3F, 0xF0, 0xFF, 0x07, 0x00, 0xC0, 0xF7, 0x3F, 0xF0, 
  0xBF, 0x0F, 0x00, 0xE0, 0xC3, 0x1F, 0xE0, 0x0F, 0x1F, 0x00, 0xE0, 0x81, 
  0x0F, 0xC0, 0x07, 0x1E, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 
  0xF0, 0x01, 0x00, 0x00, 0x00, 0x3E, 0x00, 0xE0, 0x01, 0x00, 0x00, 0x00, 
  0x1E, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x1F, 0x00, 0xC0, 0x07, 0x00, 
  0x00, 0x80, 0x0F, 0x00, 0x80, 0x07, 0xC0, 0x0F, 0x80, 0x07, 0x00, 0x80, 
  0x07, 0xF0, 0x3F, 0x80, 0x07, 0x00, 0xF0, 0x07, 0xF8, 0x7F, 0x80, 0x3F, 
  0x00, 0xFE, 0x07, 0xFC, 0xFF, 0x80, 0xFF, 0x01, 0xFF, 0x03, 0x3E, 0xF0, 
  0x01, 0xFF, 0x03, 0xFF, 0x01, 0x1E, 0xE0, 0x01, 0xFE, 0x03, 0x0F, 0x00, 
  0x0F, 0xC0, 0x03, 0xC0, 0x03, 0x0F, 0x00, 0x0F, 0xC0, 0x03, 0xC0, 0x03, 
  0x0F, 0x00, 0x0F, 0xC0, 0x03, 0xC0, 0x03, 0x0F, 0x00, 0x0F, 0xC0, 0x03, 
  0xC0, 0x03, 0x0F, 0x00, 0x0F, 0xC0, 0x03, 0xC0, 0x03, 0x0F, 0x00, 0x0F, 
  0xC0, 0x03, 0xC0, 0x03, 0xFF, 0x01, 0x1E, 0xE0, 0x01, 0xFE, 0x03, 0xFF, 
  0x03, 0x3E, 0xF0, 0x01, 0xFF, 0x03, 0xFE, 0x07, 0xFC, 0xFF, 0x80, 0xFF, 
  0x01, 0xF0, 0x07, 0xF8, 0x7F, 0x80, 0x3F, 0x00, 0x80, 0x07, 0xF0, 0x3F, 
  0x80, 0x07, 0x00, 0x80, 0x07, 0xC0, 0x0F, 0x80, 0x07, 0x00, 0xC0, 0x07, 
  0x00, 0x00, 0x80, 0x0F, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x1F, 0x00, 
  0xE0, 0x01, 0x00, 0x00, 0x00, 0x1E, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 
  0x3E, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0xE0, 0x81, 0x0F, 
  0xC0, 0x07, 0x1E, 0x00, 0xE0, 0xC3, 0x1F, 0xE0, 0x0F, 0x1F, 0x00, 0xC0, 
  0xF7, 0x3F, 0xF0, 0xBF, 0x0F, 0x00, 0x80, 0xFF, 0x3F, 0xF0, 0xFF, 0x07, 
  0x00, 0x00, 0xFF, 0x3C, 0xF0, 0xFC, 0x03, 0x00, 0x00, 0x7E, 0x3C, 0xF0, 
  0xF8, 0x01, 0x00, 0x00, 0x18, 0x3C, 0xF0, 0x60, 0x00, 0x00, 0x00, 0x00, 
  0xF8, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xF8, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F, 0x00, 
  0x00, 0x00,
};

const uint8_t* icons[iconCount] = { icon0, icon1, icon2, icon3, icon4, icon5 };

const char* iconLabels[iconCount] = {
  "タイムレコーダー",
  "記録・結果",
  "トラック",
  "GPS情報",
  "ファームウェア",
  "設定"
};

//ホーム画面の状態
enum Screen {
  SCREEN_MENU,    // アイコン選択画面
  SCREEN_TIMER,   // タイムレコーダー画面
  SCREEN_RECORD,  // 記録・結果画面
  SCREEN_TRACK,   // トラック画面
  SCREEN_GPS,     // GPS情報画面
  SCREEN_WIFI,    // ファームウェア画面
  SCREEN_SETTING  // 設定画面
};
Screen currentScreen = SCREEN_MENU;  // 現在の画面

//履歴結果画面の状態
enum ViewState {
  VIEW_FOLDER,  // フォルダ一覧
  VIEW_FILE,    // ファイル一覧
  VIEW_CSV      // CSV閲覧
};
ViewState viewState = VIEW_FOLDER;

//トラック画面の状態
enum TrackState {
  TRACK_MENU,
  TRACK_GPS,
  TRACK_SAVE,
  TRACK_MAKE
};
TrackState trackState = TRACK_MENU;

// ミリ秒を mm:ss.SSS 文字列に変換
String formatTime(unsigned long ms) {
  unsigned long sec = ms / 1000;
  unsigned long msec = (ms % 1000) / 10;
  unsigned long min = sec / 60;
  sec = sec % 60;

  char buf[16];
  sprintf(buf, "%02lu:%02lu.%02lu", min, sec, msec);
  return String(buf);
}

// 記録・結果画面に入ったときに最新のログ一覧をSDから取得
// ---------- フォルダ一覧取得 ----------
void reloadFolders() {
  folderCount = 0;
  File root = SD.open("/laplog");
  if (root) {
    while (true) {
      File entry = root.openNextFile();
      if (!entry) break;
      if (entry.isDirectory() && folderCount < 20) {
        folderList[folderCount++] = String(entry.name());
      }
      entry.close();
    }
    root.close();
  }
}

// ---------- フォルダ内ファイル取得 ----------
void reloadLapFiles(String folderName) {
  fileCount = 0;
  File folder = SD.open("/laplog/" + folderName);
  if (folder) {
    while (true) {
      File entry = folder.openNextFile();
      if (!entry) break;
      if (!entry.isDirectory() && fileCount < 50) {
        fileList[fileCount++] = String(entry.name());
      }
      entry.close();
    }
    folder.close();
  }
}

//lapのcsv取得
void loadCSV(String folderName, String fileName) {
  lapCount = 0;
  File f = SD.open("/laplog/" + folderName + "/" + fileName);

  // 1行目（ヘッダ）を読み飛ばす
  if (f.available()) f.readStringUntil('\n');

  while (f.available() && lapCount < 50) {
    String row = f.readStringUntil('\n');
    if (row.indexOf(",") > 0) laps[lapCount++] = row;
  }
  f.close();
}

//サーキット用のcsv取得
void loadtrackCSV(){
  File f = SD.open("/track/Circuite.csv");
  if (!f) {
    Serial.println("File open failed!");
    return;
  }
  // ヘッダは読み飛ばす
  if (f.available()) f.readStringUntil('\n');

  circuitCount = 0;
  while (f.available()){
    String row = f.readStringUntil('\n');
    row.trim();
    if(row.length() == 0) continue; //文字数ゼロの時飛ばす

    int col = 0;
    int start = 0;
    int idx = 0;

    //カンマで区切って8列に格納する
    while((idx = row.indexOf(',', start)) != -1 && col < 8){//indexOfでカンマの位置を特定(ない時は-1を変えす)してidxに数値を入れる
      circuits[circuitCount][col] = row.substring(start, idx);//suvstringで文字の初めの数値（場所）終わりのところ（idxの場所は読み取らない）までを保存する
      //Serial.print(circuits[circuitCount][col]);
      start = idx + 1;
      col++;
    }
    //最後のカンマに合わせる
    if (col < 8) {
      circuits[circuitCount][col] = row.substring(start);
    }
    circuitCount++;
  }
  f.close();
}
//サーキット用のcsv上書き
void savetrackCSV(){
  const char* tmpFile = "/track/tmp.csv";

  File f = SD.open(tmpFile, FILE_WRITE);
  if (!f) {
    Serial.println("File open failed!");
    return;
  }

  // ヘッダを書き込む
  f.println("CircuiteName,Latitude1,Longitude1,Latitude2,Longitude2,Length,Besttime,Besttrack");

  // 配列の内容を書き込む
  for (int i = 0; i < circuitCount; i++) {
    String lineOut = "";
    for (int j = 0; j < 8; j++) {
      lineOut += circuits[i][j];
      if (j < 7) lineOut += ",";
    }
    f.println(lineOut);
  }
  f.close();

  SD.remove("/track/Circuite.csv");          // 元ファイル削除
  SD.rename(tmpFile, "/track/Circuite.csv"); // 一時ファイルを元ファイル名に変更
  Serial.println("CSV保存完了");
}

// ---------- 新しいサーキットラインを追加 ----------------
void newtrackCSV(double lat1, double lon1, double lat2, double lon2){
  File f = SD.open("/track/Circuite.csv", FILE_APPEND);
  if (!f) {
    Serial.println("File open failed!");
    return;
  }
  if(f){
    // 日付を取得 (日本時間に調整)
    char folderName[16];
    sprintf(folderName, "%04d-%02d", gps.date.year(), gps.date.month());  // 年月
    f.println(String("新規") + folderName + "," + String(lat1, 6) + ","  + String(lon1, 6) +  "," + String(lat2, 6) + "," + String(lon2, 6) +",0,0");
    f.close();
  }
}

// ---------- WiFiのSSID,PASWORDのcsv取得 ----------------
// void loadWiFi(){
//   File f = SD.open("/WiFi_SSID_PAS/SSID_PAS.csv");
//   if (!f) {
//     Serial.println("File open failed!");
//     return;
//   }
//   int SSIDCount = 0;
//   while (f.available() && SSIDCount < 2) {
//     String row = f.readStringUntil('\n');
//     row.trim(); 
//     SSIDPAS[SSIDCount] = row;
//     Serial.print(SSIDPAS[SSIDCount]);
//     SSIDCount++;
//   }
//   f.close();
// }

// ---------- スクロール管理 ----------
int updateScroll(int index, int DISPLAY_lines) {
  static int scrollIndex = 0;
  if (index < scrollIndex) scrollIndex = index; //下に行くとき表示よりも多い時
  if (index >= scrollIndex + DISPLAY_lines) scrollIndex = index - DISPLAY_lines + 1;//うえに行くとき表示よりも少ない時
  return scrollIndex;
}

// ---------- GPSタイマー起動時の記録(GPX) ----------
void recordGPS() {
  if (!running) return;
  if (!gpsFile) return;

  // UTC時刻をISO8601形式に変換
  String isoTime = "1970-01-01T00:00:00Z";
  if (gps.time.isValid() && gps.date.isValid()) {
    int h = gps.time.hour();
    int m = gps.time.minute();
    int s = gps.time.second();
    int day = gps.date.day();
    int month = gps.date.month();
    int year = gps.date.year();
    char buf[25];
    sprintf(buf, "%04d-%02d-%02dT%02d:%02d:%02dZ", year, month, day, h, m, s);
    isoTime = String(buf);
  }

  double lat = gps.location.isValid() ? gps.location.lat() : 0.0;
  double lng = gps.location.isValid() ? gps.location.lng() : 0.0;
  double speed = gps.speed.isValid() ? gps.speed.kmph() : 0.0;
  double altitude = gps.altitude.isValid() ? gps.altitude.meters() : 0.0;
  double hdop = gps.hdop.isValid() ? gps.hdop.hdop() : 99.99;  // HDOPが無効なら大きい値を仮置き

  String lapTimeStr = formatTime(lapTime);

  // GPX形式で書き込み
  gpsFile.print("  <trkpt lat=\"");
  gpsFile.print(lat, 6);
  gpsFile.print("\" lon=\"");
  gpsFile.print(lng, 6);
  gpsFile.println("\">");

  gpsFile.print("    <ele>");
  gpsFile.print(altitude, 2);
  gpsFile.println("</ele>");

  gpsFile.print("    <time>");
  gpsFile.print(isoTime);
  gpsFile.println("</time>");

  gpsFile.print("    <speed>");
  gpsFile.print(speed, 2);
  gpsFile.println("</speed>");

  gpsFile.println("    <extensions>");
  gpsFile.print("      <lap>");
  gpsFile.print(lap);
  gpsFile.println("</lap>");
  gpsFile.print("      <lapTime>");
  gpsFile.print(lapTimeStr);
  gpsFile.println("</lapTime>");
  gpsFile.print("      <hdop>");
  gpsFile.print(hdop, 2);
  gpsFile.println("</hdop>");
  gpsFile.println("    </extensions>");

  gpsFile.println("  </trkpt>");
  
  if (millis() - lastGPSMillis >= 1000) {  // 1Hz
    lastGPSMillis = millis();
    gpsFile.flush();
  }
}

bool selectPressed = false;

// ---------- GPSのラップトリガー ------------
void checkLapTrigger() {
  if (!gps.location.isValid()) return;

  currLat = gps.location.rawLat().deg + gps.location.rawLat().billionths * 1e-9;
  currLon = gps.location.rawLng().deg + gps.location.rawLng().billionths * 1e-9;

  if (Lineacross(lineLat1, lineLat2, currLat, prevLat, lineLon1, lineLon2, currLon, prevLon)) {
    Serial.println("gpsが押されました");
    selectPressed = true;
  } else {
    selectPressed = false;  // ラップでない場合は押されていない扱い
  }
  prevLat = currLat;
  prevLon = currLon;
}

// ---------- 線分交差判定 ----------
//線分AB「A(x1, y1),B(x2, y2)」と線分CD「C(x3, y3),D(x4, y4)」で判定
bool Lineacross(double x1, double x2, double x3, double x4, double y1, double y2, double y3, double y4) {
  // ベクトルABとACの外積
  float cross1 = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
  // ベクトルABとADの外積
  float cross2 = (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1);
  // ベクトルCDとCAの外積
  float cross3 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
  // ベクトルCDとCBの外積
  float cross4 = (x4 - x3) * (y2 - y3) - (y4 - y3) * (x2 - x3);
  // 外積の符号が異なれば交差している
  return (cross1 * cross2 < 0) && (cross3 * cross4 < 0);
}

// ----------下部バー--------------
void Underber(){
  u8g2.drawBox(0, 112, 256, 16);
  u8g2.setDrawColor(0);
  // ---- HDOP値 ----
  char hdopStr[20];
  if(gps.hdop.isValid() && gps.hdop.hdop() < 20){
    sprintf(hdopStr, "HDOP:%.1f", gps.hdop.hdop());
  }else{
    sprintf(hdopStr, "HDOP:NOFIX");
  }
  u8g2.drawUTF8(60, 125, hdopStr);
  u8g2.setDrawColor(1);
}

int maxSpeed = 200;
// --------- スピードメーター(gpsからの速度)描画関数 ---------
void drawSpeedMeter(int speed) {
  int lx = 5;
  int ly = 110;
  int mx = 80;
  int my = 28;
  int rx2 = 180;
  int ry2 = 28;
  int barHeight = 28; // 上下枠
  int progressThickness = barHeight - 1; // バーの厚み
  int step = 20; // 数字の間隔

  // --------------------------
  // 枠描画（上下左右）
  // --------------------------
  int prevX = lx;
  int prevY = ly;
  for (float t = 0.01; t <= 1.0; t += 0.01) {
    int x = lx + t * (mx - lx);
    int y = ly - sin(t * PI / 2) * (ly - my);
    u8g2.drawLine(prevX, prevY, x, y);            // 下側
    u8g2.drawLine(prevX, prevY - barHeight, x, y - barHeight); // 上側
    prevX = x;
    prevY = y;
  }
  u8g2.drawLine(mx, my, rx2, ry2);
  u8g2.drawLine(mx, my - barHeight, rx2, ry2 - barHeight);
  u8g2.drawLine(lx, ly, lx, ly - barHeight);
  u8g2.drawLine(rx2, ry2, rx2, ry2 - barHeight);

  // --------------------------
  // バー描画（厚み付き）
  // --------------------------
  if (speed > maxSpeed) {
    // maxSpeed超過時 → 全体を黒く
    prevX = lx;
    prevY = ly;
    for (float t = 0.01; t <= 1.0; t += 0.01) {
      int x = lx + t * (mx - lx);
      int y = ly - sin(t * PI / 2) * (ly - my);
      for (int h = 1; h <= progressThickness; h++) {
        u8g2.drawBox(prevX, prevY - h, x - prevX + 1, 1);
      }
      prevX = x;
      prevY = y;
    }
    // 直線部分も塗りつぶす
    for (int h = 1; h <= progressThickness; h++) {
      u8g2.drawLine(mx, my - h, rx2, ry2 - h);
    }
  } else {
    // maxSpeed以下 → 通常のバー描画
    float progress = (float)speed / maxSpeed;

    if (progress <= 0.5) { // 楕円部分まで
      float tMax = progress / 0.5;
      prevX = lx;
      prevY = ly;
      for (float t = 0.01; t <= tMax; t += 0.01) {
        int x = lx + t * (mx - lx);
        int y = ly - sin(t * PI / 2) * (ly - my);
        for (int h = 1; h <= progressThickness; h++) {
          u8g2.drawLine(prevX, prevY - h, x, y - h);
        }
        prevX = x;
        prevY = y;
      }
    } else { // 直線部分まで
      prevX = lx;
      prevY = ly;
      // 楕円部分塗りつぶし
      for (float t = 0.01; t <= 1.0; t += 0.01) {
        int x = lx + t * (mx - lx);
        int y = ly - sin(t * PI / 2) * (ly - my);
        for (int h = 1; h <= progressThickness; h++) {
          u8g2.drawLine(prevX, prevY - h, x, y - h);
        }
        prevX = x;
        prevY = y;
      }
      // 直線部分塗りつぶし
      float lineProgress = (progress - 0.5) / 0.5;
      int lxStart = mx;
      int lyStart = my;
      int lxEnd = lxStart + lineProgress * (rx2 - mx);
      int lyEnd = lyStart + lineProgress * (ry2 - my);
      for (int h = 1; h <= progressThickness; h++) {
        u8g2.drawLine(lxStart, lyStart - h, lxEnd, lyEnd - h);
      }
    }
  }

  // --------------------------
  // 下枠目盛り・数字表示（枠ラインすぐ下）
  // --------------------------
  u8g2.setFont(u8g2_font_6x10_tr);
  for (int s = 0; s <= maxSpeed; s += step) {
      float p = (float)s / maxSpeed;
      int mxPos, myPos;
      if (p <= 0.5) {
          float t = p / 0.5;
          mxPos = lx + t * (mx - lx);
          myPos = ly - sin(t * PI / 2) * (ly - my);
      } else {
          float lineP = (p - 0.5) / 0.5;
          mxPos = mx + lineP * (rx2 - mx);
          myPos = my + lineP * (ry2 - my);
      }
      // 数字の縦位置を下枠ラインすぐ下に設定
      int numberY = myPos + 11; 
      u8g2.drawLine(mxPos, myPos, mxPos, myPos + 2); // 目盛り
      u8g2.setCursor(mxPos - 4, numberY);            // 数字位置
      u8g2.print(s);
  }
}

// --------- gpsのアンテナ --------------
void drawGPSSignal(float hdop, int Width, int Height, int Spacing, int X, int Y) {
  int barWidth = Width;    // バー幅
  int barHeight = Height;   // 1本の高さ
  int spacing = Spacing;     // バー間隔
  int x = X;          // 左端X
  int y = Y;          // 下端Y（バーの下端をここで揃える）

  // satStrengthを0〜3に変換
  int sat = 0;
  if (hdop <= 1.2) sat = 4;
  else if (hdop <= 1.5) sat = 3;
  else if (hdop <= 2.0) sat = 2;
  else if (hdop <= 5.0) sat = 1;
  else sat = 0;

  if (sat == 0) {
    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(x, y, "X");
  } else {
    for (int i = 0; i < sat; i++) {
      int barX = x + i * (barWidth + spacing);
      int currentHeight = barHeight * (i + 1);  // バーの高さを段階的に増やす
      int barY = y - currentHeight;             // 下端を揃えて上に伸ばす
      u8g2.drawBox(barX, barY, barWidth, currentHeight);
    }
  }
}

// ---------　近場のサーキットの距離計算 -----------
int findNearestCircuit(float gpsx, float gpsy){
  float minDist = 1e6; // 大きめの初期値
  int near = -1;
  for (int i = 0; i < circuitCount; i++){
    float x = circuits[i][2].toFloat() - gpsx;
    float y = circuits[i][1].toFloat() - gpsy;
    float d = sqrt(x*x + y*y);
    if(d < minDist) {
      minDist = d;
      near = i;
    }
  }
  return near;
}

// --------- アップデート処理用 ---------
void handleUpdate() {
  // 現在のアップロードされたファイルを取得
  HTTPUpload& upload = server.upload();
  if (upload.status == UPLOAD_FILE_START) {
    // 更新用メモリを確保（サイズ不明でもOK）
    Serial.println("更新用メモリを確保(とりあえず1.5mbまで)");
    if (!Update.begin(1.5 * 1024 * 1024)) Update.printError(Serial);
  } else if (upload.status == UPLOAD_FILE_WRITE) {// アップロード中のデータ書き込み
    // 書き込みに失敗した場合はエラー表示
    if (Update.write(upload.buf, upload.currentSize) != upload.currentSize) Update.printError(Serial);
  } else if (upload.status == UPLOAD_FILE_END) {// アップロード完了
    Serial.println("アップロード完了");
    if (Update.end(true)) {
      server.sendHeader("Access-Control-Allow-Origin", "*");
      server.send(200);
      Serial.println("テキストを送っています");
      ESP.restart();
    } else {
      Update.printError(Serial);
    }
  }
}

// --------- データログをアップロード用 ---------
void handleUploadGPX(){
  HTTPUpload& upload = server.upload();
  static File uploadFile;
  if (upload.status == UPLOAD_FILE_START) {
    uploadFile = SD.open("/" + upload.filename, FILE_WRITE);
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    if (uploadFile) uploadFile.write(upload.buf, upload.currentSize);
  } else if (upload.status == UPLOAD_FILE_END) {
    if (uploadFile) uploadFile.close();
    server.send(200, "text/plain", "Upload OK");
  }
}

// --------- データログリストをjsonにしてアップロード ---------

String json = "[";

void addTwoFolderFiles(const char* foldername) {

  File folder = SD.open(foldername);
  if (!folder || !folder.isDirectory()) return;
  File dateFolder = folder.openNextFile();
  while (dateFolder) {
    if (dateFolder.isDirectory()) {
      File file = dateFolder.openNextFile();
      while(file){
        String path = String(foldername) + "/" + dateFolder.name() + "/" + file.name();
        json += "\"" + path + "\",";
        file.close();
        file = dateFolder.openNextFile();
      }
    }
    dateFolder.close();
    dateFolder = folder.openNextFile();
  }
  folder.close();
}

void addFolderFiles(const char* foldername)
{
  File folder = SD.open(foldername);
  if (!folder || !folder.isDirectory()) return;

  File file = folder.openNextFile();

  while (file)
  {
    if (!file.isDirectory())
    {
      json += "\"";
      json += foldername;
      json += "/";
      json += file.name();
      json += "\",";
    }
    File tmp = file;
    file = folder.openNextFile();
    tmp.close();
  }
  folder.close();
}

void handleList(){
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET");
  server.sendHeader("Access-Control-Allow-Headers", "*");
  
  json = "[";
  addTwoFolderFiles("/gpslog");
  addTwoFolderFiles("/laplog");

  addFolderFiles("/besttrack");
  addFolderFiles("/track");

  if(json.endsWith(",")) json.remove(json.length()-1);
  json += "]";

  server.send(200, "application/json", json);
}

// --------- 記録やトラックを削除や編集用 ---------
void handleDownload(){
  String filename = server.arg("file");
  if (filename == "") return server.send(400, "text/plain", "No file given");
  File file = SD.open("/" + filename, FILE_READ);
  if (!file) return server.send(404, "text/plain", "File not found");
  server.streamFile(file, "application/octet-stream");
  file.close();
}
void handleDelete(){
  String filename = server.arg("file");
  if (SD.remove("/" + filename)) {
    server.send(200, "text/plain", "Deleted");
  } else {
    server.send(500, "text/plain", "Delete failed");
  }
}

int dotStage = 0;
// --------- wifi接続確認とサーバー開始 ----------
void checkwifi(){
  if(!wifiConnected){
    // if(connectedSSID == "" && connectedPASS == ""){
    //   wifiManager.startConfigPortal();
    // }
    WiFi.mode(WIFI_AP);
    WiFi.softAP("GPSLapTimer");
    Serial.println(WiFi.softAPIP());
    u8g2.setFont(u8g2_font_unifont_t_japanese1);
    u8g2.drawBox(35, 15, 185, 90);
    u8g2.setDrawColor(0);
    u8g2.setFont(u8g2_font_unifont_t_japanese2);
    u8g2.drawUTF8(40, 35, "WIFI:GPSLapTimer");
    u8g2.drawUTF8(40, 55, "を選択してください");
    u8g2.drawUTF8(40, 75, "接続完了した場合");
    u8g2.drawUTF8(40, 95, "画面が変わります");
    // u8g2.setDrawColor(1);
    u8g2.sendBuffer();
    //WiFi.begin(SSIDPAS[0].c_str(),SSIDPAS[1].c_str());//2.4gHZでないとつながらないので注意
    while (WiFi.softAPgetStationNum() == 0){
      // ボタン押下チェック
      if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime) {
        cancelWiFi = true;
        lastButtonPress = millis();
      }
      if (cancelWiFi) {
        cancelWiFi = false;
        WiFi.softAPdisconnect(true); // 現在の接続や設定をリセット
        WiFi.mode(WIFI_OFF); //wifiを切る
        u8g2.setDrawColor(1);
        currentScreen = SCREEN_MENU;
        return; // ループから抜ける
      }
    }
      
    // if (WiFi.softAPgetStationNum() > 0) {
    //     Serial.println("\nConnected, IP: " + WiFi.localIP().toString());
    // } else {
    //     Serial.println("\nCould not connect to WiFi");
    // }
    // if (!MDNS.begin("esp32")) { // esp32.local でアクセス可能
    //   Serial.println("Error setting up MDNS");
    // }
    // // Webサーバー開始（POSTを待つよう）
    // if (!serverStarted) {
    //   server.on("/update", HTTP_POST, []() {}, handleUpdate);//updateにPOSTが来たらhandleUpdateを処理する
    //   server.begin();
    //   serverStarted = true;
    //   Serial.println("OTA server started");
    // }
    wifiConnected = true;
  }

  server.handleClient();//リクエストが来ているかをloopで常に監視
  if (WiFi.softAPgetStationNum() == 0) {//接続している端末が0の時は自動で切れる
     wifiConnected = false;
     serverStarted = false;
     wifiConnected = false;
     WiFi.mode(WIFI_OFF);
     WiFi.softAPdisconnect(true); // 現在の接続や設定をリセット
     currentScreen = SCREEN_MENU;
     Serial.println("server stopped");
  }
}

// -----------------ナビゲーション--------------------------
// ==== 前ラップ軌跡 ====
#define MAX_POINTS 1800 //とりあえず30分（1hz）でやる←gpxから読み取れるように変更したい
float latBuf[MAX_POINTS];
float lonBuf[MAX_POINTS];
float currLatBuf[MAX_POINTS];
float currLonBuf[MAX_POINTS];
int pointsum = 0;
//1秒ずつの緯度経度記録用（現在の走っているログ（更新用）と表示用のログ）
int pointCount = 0;
int currPointCount = 0;
//方向角度の変数
float heading = 0;
// 描画用の配列
int cachedLatBuf[MAX_POINTS];
int cachedLonBuf[MAX_POINTS];
// //ベストタイム緯度経度のロード用配列
// float bestLatBuf[MAX_POINTS];
// float bestLonBuf[MAX_POINTS];
//描画用0.5秒ずつ更新
unsigned long lastDraw = 0;
//描画用の点の数
int cachedPointCount = 0;
//メートルの定義
float metersize = 500.0;
int bestPointCount = 0;
//ベストタイムの緯度経度の取得
void loadLatLon(int csvnum) {
  bestPointCount = 0;
  File f = SD.open("/besttrack/" + String(csvnum) + ".csv" );
  if (!f) {
    Serial.println("File open failed: " + String(csvnum));
    return;
  }
  while(f.available() && bestPointCount < MAX_POINTS){
    String line = f.readStringUntil('\n');   // 1行取得
    // カンマで分割
    int commaIndex = line.indexOf(',');
    if (commaIndex > 0) {
      String latStr = line.substring(0, commaIndex);
      String lonStr = line.substring(commaIndex + 1);

      latBuf[bestPointCount] = latStr.toFloat();
      lonBuf[bestPointCount] = lonStr.toFloat();
      bestPointCount++;
    }
  }
  f.close();
}
//ベストタイムの緯度経度の保存
int bestpointsum = 0;
void saveLatLon(int csvnum){
  const char* tmpFile = "/besttrack/tmp.csv";

  File f = SD.open(tmpFile, FILE_WRITE);
  if (!f) {
    Serial.println("File open failed!");
    return;
  }
  for (int i = 0; i < bestpointsum; i++) {
    f.print(latBuf[i],6);
    f.print(",");
    f.println(lonBuf[i],6);
  }
  f.close();

  SD.remove("/besttrack/"+ String(csvnum) +".csv");          // 元ファイル削除
  SD.rename(tmpFile, "/besttrack/"+ String(csvnum) +".csv"); // 一時ファイルを元ファイル名に変更
  Serial.println("CSV保存完了");
}

// ==== 緯度経度 -> ピクセル（回転） ====
// 緯度経度 → 枠内ピクセル変換（回転対応）
void toPixelRelative(float lat_origin, float lon_origin, float lat, float lon, float heading, int *px, int *py) {
    // 緯度・経度差をメートルに
    float dx = (lon - lon_origin) * 111000 * cos(lat_origin*M_PI/180.0);
    float dy = (lat - lat_origin) * 111000;
    
    // 回転（heading: 進行方向に合わせる）
    float cosA = cos(-heading);  // 回転方向に注意
    float sinA = sin(-heading);
    float dx_rot = dx * cosA - dy * sinA;
    float dy_rot = dx * sinA + dy * cosA;

    // 500m枠外なら無視
    if(dx_rot < -(metersize/2) || dx_rot > (metersize/2) || dy_rot < 0 || dy_rot > metersize) return;

    // 500mスケール → 96ピクセル枠
    float scale = 96.0 / metersize;

    // 三角マーク（自分）
    *px = 74 + (int)(dx_rot * scale);
    *py = 108 - (int)(dy_rot * scale);
}

void updateCachedPoints(){
  if(millis() - lastDraw < 500)return;
  lastDraw = millis();
  
  //toPixelRelative(gps.location.lat(), gps.location.lng(), latBuf[0], lonBuf[0], heading, &cachedprevX, &cachedprevY);
  cachedPointCount = 0;
  for(int i=0;i<pointCount;i++){
    int px, py;
    toPixelRelative(gps.location.lat(), gps.location.lng(), latBuf[i], lonBuf[i], heading, &px, &py);
    // キャッシュにそれぞれの変換したデータを格納する
    if(px >= 10 && px <= 126 && py >= 32 && py <= 126){
      cachedLatBuf[i] = px;
      cachedLonBuf[i] = py;
      cachedPointCount++;
    }
  }
}

// ------ミニマップ描画用---------
void drawMiniMap(){
  // ====  min/max を探す ====
  Serial.print(bestPointCount);
  float minLat = latBuf[0], maxLat = latBuf[0];
  float minLon = lonBuf[0], maxLon = lonBuf[0];
  for (int i = 1; i < bestPointCount; i++) {
    if (latBuf[i] < minLat) minLat = latBuf[i];
    if (latBuf[i] > maxLat) maxLat = latBuf[i];
    if (lonBuf[i] < minLon) minLon = lonBuf[i];
    if (lonBuf[i] > maxLon) maxLon = lonBuf[i];
  }

  // ====  中心やスケールを計算 ====
  const float PAD = 0.05; // 5%余白
  float centerLat = (minLat + maxLat) / 2.0;
  float centerLon = (minLon + maxLon) / 2.0;

  // 1度あたりの距離換算
  float mPerDegLat = 110574.0;
  float mPerDegLon = 111320.0 * cos(centerLat * PI / 180.0);

  float latRange = (maxLat - minLat) * mPerDegLat;
  float lonRange = (maxLon - minLon) * mPerDegLon;

  // 余白を加える
  latRange *= (1.0 + PAD * 2.0);
  lonRange *= (1.0 + PAD * 2.0);

  float scaleX = 128  / lonRange;
  float scaleY = 100 / latRange;
  float scale = min(scaleX, scaleY);

  // 中心座標（ピクセル）
  float pxCenter = 128 / 2.0;
  float pyCenter = 100 / 2.0;

  // ==== 3. 線を描く ====
  for (int i = 1; i < bestPointCount; i++) {
    // 経度 → X
    float dx1 = (lonBuf[i-1] - centerLon) * mPerDegLon;
    float dx2 = (lonBuf[i]   - centerLon) * mPerDegLon;
    int x1 = (int)(pxCenter + dx1 * scale + 0.5);
    int x2 = (int)(pxCenter + dx2 * scale + 0.5);

    // 緯度 → Y（反転）
    float dy1 = (latBuf[i-1] - centerLat) * mPerDegLat;
    float dy2 = (latBuf[i]   - centerLat) * mPerDegLat;
    int y1 = (int)(pyCenter - dy1 * scale + 0.5);
    int y2 = (int)(pyCenter - dy2 * scale + 0.5);
    Serial.print(x1);
    Serial.print(",");
    Serial.println(y1);
    // 線を描画
    int thickness = 2; // 好きな太さ
    for (int tx = -thickness; tx <= thickness; tx++) {
      for (int ty = -thickness; ty <= thickness; ty++) {
        u8g2.drawLine(x1 + 128 + tx, y1 + 25 + ty, x2 + 128 + tx, y2 + 28 + ty);
      }
    }
  }
}

void setup() {
  pinMode(HSPI_CS, OUTPUT);
  digitalWrite(HSPI_CS, HIGH);  // 起動直後は無効に
  Serial.begin(115200);
  ss.begin(115200, SERIAL_8N1, RX_PIN, TX_PIN);
  Wire.begin(21, 22);

  u8g2.begin();
  u8g2.setContrast(165);
  u8g2.drawXBMP(0, 0, 256, 128, openning);
  u8g2.sendBuffer();
  delay(100);  // SDやSPI機器が安定するまで少し待つ
  //SDカードの初期化とログ一覧の読み込み
  spiHSPI.begin(HSPI_SCK, HSPI_MISO, HSPI_MOSI, HSPI_CS);
  if (!SD.begin(HSPI_CS, spiHSPI)) {
    Serial.println("SD init failed!");
    return;
  }
  Serial.println("SD開始できてる");
  // ログ一覧を更新順で読み込む
  reloadFolders();
  // サーキットの名前、緯度経度（ラップ判定ライン）,全長、ベストタイムを読み込む
  loadtrackCSV();
  //// wifiのssidとpasswordを読み込む
  //loadWiFi();
  pinMode(BTN_LEFT, INPUT_PULLUP);
  pinMode(BTN_RIGHT, INPUT_PULLUP);
  pinMode(BTN_SELECT, INPUT_PULLUP);
  pinMode(BTN_BACK, INPUT_PULLUP);
  // //test------------------
  // float lat0 = 35.435670, lon0 = 139.961900;
  // for(int i=0;i<MAX_POINTS;i++){
  //     latBuf[i] = lat0 + 0.00036*i + 0.00010*sin(i*0.1);
  //     lonBuf[i] = lon0  ;
  // }
  // pointCount = MAX_POINTS;
  // //-----------------------
  delay(1000);
}

void loop() {
  // GPSデータ取得
  while (ss.available() > 0) gps.encode(ss.read());
  //GPSタイマー起動時の記録(10hzずつ)
  if(millis() - gpxrecord > 100){
    gpxrecord = millis();
    recordGPS();
    if(running){
      if(pointsum < 1800){
        currLatBuf[pointsum] = gps.location.lat();
        currLonBuf[pointsum] = gps.location.lng();
        pointsum++;
      }
    }
  }
  // ===== ボタン処理 =====
  //ホーム画面のボタン処理
  if (currentScreen == SCREEN_MENU) {
    if (digitalRead(BTN_RIGHT) == LOW && millis() - lastButtonPress > debounceTime) {
      if (selected < iconCount - 1) {
        selected++;
        if (selected > startIndex + 3 && startIndex < iconCount - 4) startIndex++;
      }
      lastButtonPress = millis();
    }
    if (digitalRead(BTN_LEFT) == LOW && millis() - lastButtonPress > debounceTime) {
      if (selected > 0) {
        selected--;
        if (selected < startIndex && startIndex > 0) startIndex--;
      }
      lastButtonPress = millis();
    }
    if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime) {
      currentScreen = Screen(selected + 1);  // MENU -> 各画面
      lastButtonPress = millis();
    }
  }

  //---------タイムレコーダーのボタン処理---------
  if (currentScreen == SCREEN_TIMER) {
    if (running) {
      checkLapTrigger();
    }
    if (digitalRead(BTN_RIGHT) == LOW && millis() - lastButtonPress > debounceTime && !running) {
      if (selectTimer < 2) {
        selectTimer++;
        if(selectTimer == 2){
          loadLatLon(Csvnum);
        }
      }
      lastButtonPress = millis();
    }
    if (digitalRead(BTN_LEFT) == LOW && millis() - lastButtonPress > debounceTime && !running) {
      if (selectTimer > 0) {
        selectTimer--;
      }
      lastButtonPress = millis();
    }
    //タイムレコーダーのボタン処理(selectボタンで現在動かしている)
    if ((digitalRead(BTN_SELECT) == LOW || selectPressed) && currentScreen == SCREEN_TIMER && millis() - lastButtonPress > debounceTime) {
      lastButtonPress = millis();
      running = true;
      lap++;
      lastLapDuration = lapTime;         // 表示用にコピー
      lastLapDisplayTime = millis();     // 今の時刻を記録
      showLapTime = true;                // 5秒表示モードON
      lapTimes[lap] = lapTime;  // 現ラップを配列に保存
      if (lap > 1) {
          gap = lapTimes[lap] - lapTimes[lap - 1]; // 前ラップとの差
        if (bestTime > lapTime) {
          bestTime = lapTime;
        }
        if(Csvbesttime > bestTime || Csvbesttime == 0){
          Csvbesttime = bestTime;
          Serial.println(Csvbesttime);
          if(selectTimer == 2 || selectTimer == 0){
            for (int i = 0; i < pointsum; i++){
              latBuf[i] = currLatBuf[i];
              lonBuf[i] = currLonBuf[i];
            }
            bestpointsum = pointsum;
            pointsum = 0;
          }
        }
        if(selectTimer == 1){
          for (int i = 0; i < pointsum; i++){
            latBuf[i] = currLatBuf[i];
            lonBuf[i] = currLonBuf[i];
            Serial.print("latBuf[");
            Serial.print(i);
            Serial.print("] = ");
            Serial.println(latBuf[i], 6);  // 小数点6桁まで表示
          }
          pointsum = 0;
        } else if(selectTimer == 2 || selectTimer == 0){
          pointsum = 0;
        }
      }
      lapStart = millis();
      lastGPSMillis = millis();  // GPS記録タイマー初期化

      // ----- 初回測定時に日付フォルダを作成 -----
      if (lapcurrentFolder == "") {
        // 日付を取得 (日本時間に調整)
        int hourJST = (gps.time.hour() + 9) % 24;
        char folderName[16];
        sprintf(folderName, "%04d-%02d", gps.date.year(), gps.date.month());  // 年月

        lapcurrentFolder = "/laplog/" + String(folderName);
        gpscurrentFolder = "/gpslog/" + String(folderName);
        // フォルダ作成
        if (!SD.exists(lapcurrentFolder)) {
          SD.mkdir(lapcurrentFolder);
          SD.mkdir(gpscurrentFolder);
        }
      }

      // ----- 初回測定時にファイル名作成 -----
      if (lapFileName == "") {
        char fileName[32];
        int hourJST = (gps.time.hour() + 9) % 24;  // 日本時間に補正
        sprintf(fileName, "%02d%02d_%02d-%02d",
                gps.date.month(), gps.date.day(),
                hourJST, gps.time.minute());
        lapFileName = lapcurrentFolder + "/" + String(fileName) + ".csv";
        gpsFileName = gpscurrentFolder + "/" + String(fileName) + ".gpx";

        // 初回ラップのときだけヘッダを書き込む
        if (lap == 1) {
          lapFile = SD.open(lapFileName, FILE_WRITE);
          if (lapFile) {
            lapFile.println("lap,lapTime,bestTime");
            lapFile.close();
          }
          gpsFile = SD.open(gpsFileName, FILE_WRITE);
          if (gpsFile) {
            gpsFile.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
            gpsFile.println("<gpx version=\"1.1\" creator=\"MyGPSLogger\">");
            gpsFile.println("  <trk>");
            gpsFile.println("    <name>Lap Track</name>");
            gpsFile.println("    <trkseg>");
          }
        }
      }
      // 毎回ラップを追記
      if (lapTime > 0) {
        lapFile = SD.open(lapFileName, FILE_APPEND);
        if (lapFile) {
          lapFile.print(lap - 1);
          lapFile.print(",");
          lapFile.print(formatTime(lapTime));
          lapFile.print(",");
          lapFile.print(formatTime(bestTime));
          lapFile.println();
          lapFile.close();
        }
      }
    }
    if (digitalRead(BTN_BACK) == LOW && !running && millis() - lastButtonPress > debounceTime) {
      lastButtonPress = millis();
      currentScreen = SCREEN_MENU;
    } else if (digitalRead(BTN_BACK) == LOW && running && millis() - lastButtonPress > debounceTime) {
       //今までの記録よりもベストタイムの時更新
      if(Csvbesttime == bestTime){
        circuits[Csvnum - 1][6] = String(Csvbesttime);
        Serial.println(circuits[Csvnum - 1][6].toInt());
        //緯度経度も今までの記録よりベストタイムの時更新する
        saveLatLon(Csvnum);
        savetrackCSV();
      }

      lastButtonPress = millis();
      lap = 0;
      lapStart = 0;
      lapTime = 0;
      bestTime = 999999;
      lastGPSMillis = 0;  // GPS記録タイマー初期化
      running = false;
      lapcurrentFolder = "";
      lapFileName = "";
      selectPressed = false;
      showLapTime = false; 
      // 記録終了時
      gpsFile.println("    </trkseg>");
      gpsFile.println("  </trk>");
      gpsFile.println("</gpx>");
      lapFile.close();
      gpsFile.close();
    }
  }

  // ---------記録・結果画面のボタン処理--------------
  if (currentScreen == SCREEN_RECORD) {
    if (!recordfolder) {
      reloadFolders();
      recordfolder = true;
    }
    // フォルダを選んだとき
    if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime) {
      lastButtonPress = millis();  // 押した時間を記録
      if (viewState == VIEW_FOLDER) {
        if (!recordfile) {
          reloadLapFiles(folderList[folderIndex]);
          recordfile = true;
          fileIndex = 0;
          fileScroll = 0;
        }
        viewState = VIEW_FILE;
      } else if (viewState == VIEW_FILE) {
        if (!recordcsv) {
          loadCSV(folderList[folderIndex], fileList[fileIndex]);
          csvIndex = 0;
          csvScroll = 0;
          recordcsv = true;
        }
        viewState = VIEW_CSV;
      }
    }

    // 上下キーで移動
    if (millis() - lastButtonPress > debounceTime) {
      if (viewState == VIEW_FOLDER) {
        if (digitalRead(BTN_LEFT) == LOW && folderIndex > 0) {
          folderIndex--;
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_RIGHT) == LOW && folderIndex < folderCount - 1) {
          folderIndex++;
          lastButtonPress = millis();
        }
      } else if (viewState == VIEW_FILE) {
        if (digitalRead(BTN_LEFT) == LOW && fileIndex > 0) {
          fileIndex--;
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_RIGHT) == LOW && fileIndex < fileCount - 1) {
          fileIndex++;
          lastButtonPress = millis();
        }
      } else if (viewState == VIEW_CSV) {
        if (digitalRead(BTN_LEFT) == LOW && csvIndex > 0) {
          csvIndex--;
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_RIGHT) == LOW && csvIndex < lapCount - 1) {
          csvIndex++;
          lastButtonPress = millis();
        }
      }
    }

    if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime) {
      lastButtonPress = millis();
      if (viewState == VIEW_CSV) {
        viewState = VIEW_FILE;
        recordcsv = false;
      } else if (viewState == VIEW_FILE) {
        viewState = VIEW_FOLDER;
        recordfile = false;
      } else if (viewState == VIEW_FOLDER) {
        currentScreen = SCREEN_MENU;
        recordfolder = false;
      }
    }
  }
  if (currentScreen != SCREEN_RECORD) {
    recordfolder = false;
  }

  //----------トラックのボタン処理-------------
  if (currentScreen == SCREEN_TRACK) {
    if(trackState == TRACK_MENU){
      if (digitalRead(BTN_RIGHT) == LOW && millis() - lastButtonPress > debounceTime) {
        if (selectTrack < 2) {
          selectTrack++;
        }
        lastButtonPress = millis();
      }
      if (digitalRead(BTN_LEFT) == LOW && millis() - lastButtonPress > debounceTime) {
        if (selectTrack > 0) {
          selectTrack--;
        }
        lastButtonPress = millis();
      }
      if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime) {
        trackState = TrackState(selectTrack + 1);
        lastButtonPress = millis();
      }
      if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime) {
        currentScreen = SCREEN_MENU;
        lastButtonPress = millis();
        selectTrack = 0;
      }
    }
    if(trackState == TRACK_GPS){
      if(gps.hdop.hdop() < 5.0){
        if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime){
          showMessage = true;
          int nearf = findNearestCircuit(gps.location.lng(), gps.location.lat());
          nowcircuit = circuits[nearf][0];
          lineLat1 = circuits[nearf][1].toFloat();
          lineLon1 = circuits[nearf][2].toFloat();
          lineLat2 = circuits[nearf][3].toFloat();
          lineLon2 = circuits[nearf][4].toFloat();
          Csvbesttime = circuits[nearf][6].toInt();
          Csvnum = circuits[nearf][7].toInt();
          lastButtonPress = millis();
        }
      }
      if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime) {
        trackState = TRACK_MENU;
        lastButtonPress = millis();
      }
    }
    if(trackState == TRACK_SAVE){
      if(viewstate == false){
        if (digitalRead(BTN_RIGHT) == LOW && millis() - lastButtonPress > debounceTime && circuitIndex < circuitCount - 1 ) {
          circuitIndex++;
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_LEFT) == LOW && millis() - lastButtonPress > debounceTime && circuitIndex > 0) {
          circuitIndex--;
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime){
          viewstate = true;
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime) {
          trackState = TRACK_MENU;
          circuitIndex = 0;
          lastButtonPress = millis();
        }
      } else if (viewstate == true){
        if (digitalRead(BTN_RIGHT) == LOW && millis() - lastButtonPress > debounceTime && viewstateframe < 2 ) {
          if(showdetail == false && showdeleat == false){
            viewstateframe++;
          }
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_LEFT) == LOW && millis() - lastButtonPress > debounceTime && viewstateframe > 0 ) {
          if(showdetail == false && showdeleat == false){
            viewstateframe--;
          }
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime){
          //レコードライン設定の時
          if(viewstateframe == 0){
            nowcircuit = circuits[circuitIndex][0];
            lineLat1 = circuits[circuitIndex][1].toFloat();
            lineLon1 = circuits[circuitIndex][2].toFloat();
            lineLat2 = circuits[circuitIndex][3].toFloat();
            lineLon2 = circuits[circuitIndex][4].toFloat();
            Csvbesttime = circuits[circuitIndex][6].toInt();
            Csvnum = circuits[circuitIndex][7].toInt();
            // Serial.println(circuits[circuitIndex][1]);
            // Serial.println(circuits[circuitIndex][2]);
            // Serial.println(circuits[circuitIndex][3]);
            // Serial.println(circuits[circuitIndex][4]);
            Serial.println(circuits[circuitIndex][6]);
            Serial.println(circuits[circuitIndex][7]);
            //できたかの表示
            showMessage = true;
          } else if(viewstateframe == 1){
            loadLatLon(circuits[circuitIndex][7].toInt());
            showdetail = true;
          } else if (viewstateframe == 2 && showdeleat == false) {
            showdeleat = true;
          } else if (viewstateframe == 2 && showdeleat == true) {
            showMessage = true;
            showdeleat = false;
            Csvbesttime = 0;
            circuits[circuitIndex][6] = "0";
            savetrackCSV();
          }
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime && showdetail == false) {
          if(showdeleat == false){
            viewstate = false;
            viewstateframe = 0;
          }else if(showdeleat == true){
            showdeleat = false;
          }
          showMessage = false;
          lastButtonPress = millis();
        }
        if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime && showdetail == true){
          showdetail = false;
          showMessage = false;
          lastButtonPress = millis();
        }
      }
    }
    if(trackState == TRACK_MAKE){
      if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime && firstpoint == false){
        firstpoint = true;
        LAT1 = gps.location.lat();
        LON1 = gps.location.lng();
        lastButtonPress = millis();
      } else if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime && firstpoint == true && showMessage == false){
        LAT2 = gps.location.lat();
        LON2 = gps.location.lng();
        newtrackCSV(LAT1, LON1, LAT2, LON2);
        loadtrackCSV();
        showMessage = true;
        lastButtonPress = millis();
      }
      if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime) {
        if (showMessage == true){
          showMessage = false;
          firstpoint = false;
          trackState = TRACK_MENU;
          lastButtonPress = millis();
        }
        if (firstpoint == false){
          trackState = TRACK_MENU;
          lastButtonPress = millis();
        } else if (firstpoint == true){
          firstpoint = false;
          lastButtonPress = millis();
        }
      }
    }
  }

  //GPS情報のボタン処理
  if (currentScreen == SCREEN_GPS) {
    if (digitalRead(BTN_BACK) == LOW) {
      currentScreen = SCREEN_MENU;
    }
  }

  //ファームウェアのボタン処理
  if (currentScreen == SCREEN_WIFI ) {
    checkwifi();
    // if(wifiConnected == true){
    //   if (digitalRead(BTN_RIGHT) == LOW && millis() - lastButtonPress > debounceTime) {
    //     if (selectgps < 2) {
    //       selectgps++;
    //     }
    //     lastButtonPress = millis();
    //   }
    //   if (digitalRead(BTN_LEFT) == LOW && millis() - lastButtonPress > debounceTime) {
    //     if (selectgps > 0) {
    //       selectgps--;
    //     }
    //     lastButtonPress = millis();
    //   }
    //   if (digitalRead(BTN_SELECT) == LOW && millis() - lastButtonPress > debounceTime) {
    //     selectGPS = true;
    //     if(selectgps == 0){
    //       // Webサーバー開始（POSTを待つよう）
    //       if (!serverStarted) {
    //         server.on("/update", HTTP_POST, []() {}, handleUpdate);//updateにPOSTが来たらhandleUpdateを処理する
    //         server.begin();
    //         serverStarted = true;
    //         Serial.println("OTA アップデートserver started");
    //       }
    //     } else if(selectgps == 1){
    //       if (!serverStarted) {
    //         server.on("/uploadcsv", HTTP_POST, []() {}, handleUploadGPX);
    //         server.begin();
    //         serverStarted = true;
    //         Serial.println("OTA アップロードserver started");
    //       }
    //     } else {
    //       if (!serverStarted) {
    //         server.on("/download", HTTP_GET, handleDownload);
    //         server.on("/delete", HTTP_GET, handleDelete);
    //         server.begin();
    //         serverStarted = true;
    //         Serial.println("OTA ダウンロード・削除server started");
    //       }
    //     }
    //     lastButtonPress = millis();
    //   }
    // }
    if(wifiConnected == true){
      if (!serverStarted) {
        server.on("/update", HTTP_POST, []() {}, handleUpdate);//updateにPOSTが来たらhandleUpdateを処理する
        server.on("/uploadcsv", HTTP_POST, []() {}, handleUploadGPX);
        server.on("/list", HTTP_GET, handleList);
        server.on("/download", HTTP_GET, handleDownload);
        server.on("/delete", HTTP_GET, handleDelete);
        server.begin();
        Serial.println("OTA アップデートserver started");
        Serial.println("OTA アップロードserver started");
        Serial.println("OTA ダウンロード・削除server started");
        Serial.println(WiFi.softAPIP());
        serverStarted = true;
      }
    }
    
    if (digitalRead(BTN_BACK) == LOW && millis() - lastButtonPress > debounceTime) {
      // if(selectGPS == false){
      //   cancelWiFi = false;
      //   WiFi.disconnect(true);
      //   wifiConnected = false;
      //   selectgps = 0;
      //   currentScreen = SCREEN_MENU;
      // } else if(selectGPS == true){
        server.stop();  // HTTPサーバを終了
        serverStarted = false;
        wifiConnected = false;
        WiFi.disconnect(true);
        WiFi.mode(WIFI_OFF);
        Serial.println("OTA server stopped");
        selectGPS = false;
        currentScreen = SCREEN_MENU;
      // }
      lastButtonPress = millis();
    }
  }
  //設定のボタン処理
  if (currentScreen == SCREEN_SETTING) {
    if (digitalRead(BTN_LEFT) == LOW && contrast > 0) {
      contrast -= 10;
      delay(200);
    }
    if (digitalRead(BTN_RIGHT) == LOW && contrast < 250) {
      contrast += 10;
      delay(200);
    }
    if (digitalRead(BTN_BACK) == LOW) {
      currentScreen = SCREEN_MENU;
    }
  }

  // ===== 描画 =====
  u8g2.firstPage();
  do {
    if (currentScreen == SCREEN_MENU) {
      for (int i = 0; i < 5; i++) {
        int iconIndex = startIndex + i;
        if (iconIndex >= iconCount) break;
        int x = 4 + i * 54;
        int y = 2;
        u8g2.drawXBMP(x, y, 50, 50, icons[iconIndex]);
        if (iconIndex == selected) {
          u8g2.drawFrame(x - 2, y - 2, 54, 54);
          u8g2.setFont(u8g2_font_unifont_t_japanese3);
          u8g2.drawUTF8(0, 70, iconLabels[iconIndex]);
          u8g2.drawLine(0, 72, 256, 72);
          //それぞれの項目でのヒント詳細
          if (selected == 0){
            u8g2.drawUTF8(0, 88, nowcircuit.c_str());
          } else if(selected == 1){
            u8g2.drawUTF8(0, 88, "今までのラップタイムや結果");
          }else if(selected == 2){
            u8g2.drawUTF8(0, 88, "サーキット選択や作成");
          }else if(selected == 3){
            u8g2.drawUTF8(0, 88, "現在の位置情報や正確度");
          }else if(selected == 4){
            u8g2.drawUTF8(0, 88, "アップデートやPCにデータを送信");
          }else if(selected == 5){
            u8g2.drawUTF8(0, 88, "バックライトやトラック削除など");
          }
        }
      }
      //下のバーについて
      Underber();
      u8g2.setDrawColor(0);
      u8g2.drawUTF8(1, 125, "GPS");
      drawGPSSignal(gps.hdop.hdop(), 2, 2, 1, 30, 125);
      u8g2.setDrawColor(1);
    } else {
      u8g2.setFont(u8g2_font_unifont_t_japanese2);
      switch (currentScreen) {
        case SCREEN_TIMER:
          {
            if(selectTimer == 0){
              unsigned long now = millis();
              if (running) {
                lapTime = now - lapStart;
              }
              // -----gpsアンテナ-----
              drawGPSSignal(gps.hdop.hdop(), 4, 6, 2, 5, 21);
              u8g2.setFont(u8g2_font_unifont_t_japanese2);
              u8g2.drawStr(6, 32, "GPS");

              // ----タコメーター------
              drawSpeedMeter(gps.speed.kmph());

              // ---- Lap数 ----
              u8g2.drawFrame(202, 35, 54, 25);
              u8g2.setFont(u8g2_font_7x14_tr);
              u8g2.drawStr(180, 58, "LAP");
              u8g2.setFont(u8g2_font_luBS18_tr);
              char buf[8];
              sprintf(buf, "%d", lap);
              int lapWidth = u8g2.getUTF8Width(buf);
              u8g2.drawUTF8(255 - lapWidth, 56, buf); // 右揃え

              //-------gapタイム----------
              u8g2.drawFrame(26, 104, 100, 24);
              u8g2.setFont(u8g2_font_6x10_tr);
              u8g2.drawStr(25,106, "GAP");
              u8g2.setFont(u8g2_font_luBS18_tr);
              if ( lap > 2) {
                char Gap[16];
                if (gap >= 0) {
                  sprintf(Gap, "+%02lu.%02lu", gap/1000, (gap%1000)/10);  // プラスは + 表示
                } else {
                  long absgap = -gap;  // 数値を正に変換
                  sprintf(Gap, "-%02lu.%02lu", absgap/1000, (absgap%1000)/10);
                }
                u8g2.drawUTF8(30, 125, Gap);
              }
              
              // ---- Lap Time ----
              u8g2.drawFrame(88, 66, 168, 32);
              u8g2.setFont(u8g2_font_7x14_tr);
              u8g2.drawStr(85, 65, "TIME");
              u8g2.setFont(u8g2_font_luBS24_tr);
              u8g2.setCursor(90, 95);
              if (lap > 0) {
                if (showLapTime && millis() - lastLapDisplayTime < laptimeDisplay && lap != 1) {
                  // ラップ検出後5秒間は固定表示
                  u8g2.print(formatTime(lastLapDuration));
                } else {
                  // それ以降は進行中のラップタイムを表示
                  u8g2.print(formatTime(lapTime));
                  showLapTime = false;  // 5秒を過ぎたらフラグOFF
                }
              } else {
                u8g2.print("00:00.00");
              }

              // ---- Best Time ----
              u8g2.drawFrame(133, 104, 123, 24);
              u8g2.setFont(u8g2_font_6x10_tr);
              u8g2.drawStr(132, 106, "BEST");
              u8g2.setFont(u8g2_font_luBS18_tr);
              u8g2.setCursor(135, 125);
              if (lap > 1) {
                u8g2.print(formatTime(bestTime));
              } else {
                u8g2.print("00:00.00");
              }

              // ---- Speed (GPSから取る。未Fix時は0km/h) ----
              u8g2.setFont(u8g2_font_luBS24_tr);
              double speed = gps.speed.isValid() ? gps.speed.kmph() : 0.0;
              char spd[16];
              sprintf(spd, "%.0f", speed);
              // 右揃え用に文字幅取得
              int textWidth = u8g2.getUTF8Width(spd);
              // 右端座標を 200 とした場合
              int x = 250 - textWidth;
              // 描画
              u8g2.drawUTF8(x, 30, spd);
              u8g2.setFont(u8g2_font_6x10_tr);
              u8g2.drawUTF8(238, 34, "Kmh");
            } else if (selectTimer == 1 || selectTimer == 2){
              //-------------エンデューロver----------------------------------
              unsigned long now = millis();
              if (running) {
                lapTime = now - lapStart;
              }
              // -----gpsアンテナ-----
              drawGPSSignal(gps.hdop.hdop(), 4, 6, 2, 5, 21);
              u8g2.setFont(u8g2_font_unifont_t_japanese2);
              u8g2.drawStr(6, 32, "GPS");

              //------ 現在時刻 -------
              u8g2.drawFrame(33, 0, 168, 30);
              u8g2.setFont(u8g2_font_luBS24_tr);
              int hourJST = (gps.time.hour() + 9) % 24;
              char time[20];
              sprintf(time, "%02d:%02d:%02d", hourJST, gps.time.minute(), gps.time.second());
              u8g2.drawUTF8(35, 28, time);

              // ---- Lap数 ----
              u8g2.drawFrame(202, 35, 54, 25);
              u8g2.setFont(u8g2_font_7x14_tr);
              u8g2.drawStr(180, 58, "LAP");
              u8g2.setFont(u8g2_font_luBS18_tr);
              char buf[8];
              sprintf(buf, "%d", lap);
              int lapWidth = u8g2.getUTF8Width(buf);
              u8g2.drawUTF8(255 - lapWidth, 56, buf); // 右揃え
              
              // ---- Lap Time ----
              u8g2.drawFrame(133, 68, 123, 24);
              u8g2.setFont(u8g2_font_6x10_tr);
              u8g2.drawStr(132, 70, "TIME");
              u8g2.setFont(u8g2_font_luBS18_tr);
              u8g2.setCursor(135, 90);
              if (lap > 0) {
                if (showLapTime && millis() - lastLapDisplayTime < laptimeDisplay && lap != 1) {
                  // ラップ検出後5秒間は固定表示
                  u8g2.print(formatTime(lastLapDuration));
                } else {
                  // それ以降は進行中のラップタイムを表示
                  u8g2.print(formatTime(lapTime));
                  showLapTime = false;  // 5秒を過ぎたらフラグOFF
                }
              } else {
                u8g2.print("00:00.00");
              }

              // ---- Best Time ----
              u8g2.drawFrame(133, 104, 123, 24);
              u8g2.setFont(u8g2_font_6x10_tr);
              u8g2.drawStr(132, 106, "BEST");
              u8g2.setFont(u8g2_font_luBS18_tr);
              u8g2.setCursor(135, 125);
              if (lap > 1) {
                u8g2.print(formatTime(bestTime));
              } else {
                u8g2.print("00:00.00");
              }

              // ---- Speed (GPSから取る。未Fix時は0km/h) ----
              u8g2.setFont(u8g2_font_luBS24_tr);
              double speed = gps.speed.isValid() ? gps.speed.kmph() : 0.0;
              char spd[16];
              sprintf(spd, "%.0f", speed);
              // 右揃え用に文字幅取得
              int textWidth = u8g2.getUTF8Width(spd);
              // 右端座標を 200 とした場合
              int x = 250 - textWidth;
              // 描画
              u8g2.drawUTF8(x, 30, spd);
              u8g2.setFont(u8g2_font_6x10_tr);
              u8g2.drawUTF8(238, 34, "Kmh");

              //---------- gpsナビ ------------------
              u8g2.drawFrame(0, 32, 128, 96);
              u8g2.drawLine(4, 36, 4, 124);
              u8g2.drawLine(4, 36, 8, 36);
              char meter[16];
              sprintf(meter, "%.0f", metersize);
              u8g2.drawUTF8(9, 42, meter);
              u8g2.drawLine(4, 81, 6, 81);
              u8g2.drawLine(4, 124, 8, 124);
              u8g2.drawUTF8(9, 126, "0m");

              // 進行方向（北、東、南、西）
              if (gps.speed.kmph() > 1.0) {  // 速度が1km/h以上
                heading = gps.course.deg();
                Serial.println(heading);
                // ここでコンパス表示更新
              }
              if(selectTimer == 1){
                if (lap > 2 ){
                  // 軌跡の点を0.5秒ずつ更新
                  updateCachedPoints();

                  //cacheの点から描画のloopを行う
                  int prevX = cachedLatBuf[0];
                  int prevY = cachedLonBuf[0];
                  for (int i = 1; i < cachedPointCount; i++) {
                    int px = cachedLatBuf[i];
                    int py = cachedLonBuf[i];
                    // px, py が次の点
                    int thickness = 2; // 太さ
                    for(int tx=-thickness; tx<=thickness; tx++){
                        for(int ty=-thickness; ty<=thickness; ty++){
                            //
                            u8g2.drawLine(prevX+tx, prevY+ty, px+tx, py+ty);
                        }
                    }
                    prevX = px;
                    prevY = py;
                  }
                }
                if(lap == 0){
                  u8g2.setFont(u8g2_font_unifont_t_japanese3);
                  u8g2.drawUTF8(25,75, "周回モード");
                  u8g2.drawUTF8(15,95, "(走行の軌跡)");
                  u8g2.setFont(u8g2_font_6x10_tr);
                } 
                if(lap == 1){
                  u8g2.setFont(u8g2_font_unifont_t_japanese3);
                  u8g2.drawUTF8(25,75, "経路設定中");
                  u8g2.setFont(u8g2_font_6x10_tr);
                }
              }

              if(selectTimer == 2){
                if(!running){
                  u8g2.setFont(u8g2_font_unifont_t_japanese3);
                  u8g2.drawUTF8(25,75, "SDモード");
                  u8g2.drawUTF8(15,95, "(ベストの軌跡)");
                  u8g2.setFont(u8g2_font_6x10_tr);
                }
                if (running){
                  // 軌跡の点を0.5秒ずつ更新
                  updateCachedPoints();

                  //cacheの点から描画のloopを行う
                  int prevX = cachedLatBuf[0];
                  int prevY = cachedLonBuf[0];
                  for (int i = 1; i < cachedPointCount; i++) {
                    int px = cachedLatBuf[i];
                    int py = cachedLonBuf[i];
                    // px, py が次の点
                    int thickness = 2; // 太さ
                    for(int tx=-thickness; tx<=thickness; tx++){
                        for(int ty=-thickness; ty<=thickness; ty++){
                            //
                            u8g2.drawLine(prevX+tx, prevY+ty, px+tx, py+ty);
                        }
                    }
                    prevX = px;
                    prevY = py;
                  }
                }
              }
              u8g2.drawCircle(74, 116, 10, U8G2_DRAW_ALL);
              u8g2.setDrawColor(0);
              u8g2.drawCircle(74, 116, 9, U8G2_DRAW_ALL);
              u8g2.setDrawColor(1);
              u8g2.drawTriangle(74, 108, 64, 123, 84, 123);
            }
          }
          break;



        case SCREEN_RECORD:
          u8g2.setFont(u8g2_font_6x10_tr);
          if (folderCount == 0) {
            u8g2.drawStr(0, 22, "No File");
          } else if (viewState == VIEW_FOLDER) {
            u8g2.setDrawColor(1);
            u8g2.drawBox(0, 0, 258, 20);

            u8g2.setDrawColor(0);
            u8g2.setFont(u8g2_font_unifont_t_japanese1);
            u8g2.drawUTF8(0, 16, "ファイルを選ぶ");

            u8g2.setDrawColor(1);

            if (folderIndex < folderScroll) folderScroll = folderIndex;
            if (folderIndex >= folderScroll + DISPLAY_LINES) folderScroll = folderIndex - DISPLAY_LINES + 1;

            for (int i = 0; i < DISPLAY_LINES && (i + folderScroll) < folderCount; i++) {
              int idx = i + folderScroll;
              int y = 33 + i * 14;
              if (idx == folderIndex) u8g2.drawFrame(0, y - 12, 256, 14);
              u8g2.drawUTF8(2, y, folderList[idx].c_str());
            }
          }

          // -------- ファイル一覧 --------
          else if (viewState == VIEW_FILE) {

            u8g2.setDrawColor(1);
            u8g2.drawBox(0, 0, 258, 20);

            u8g2.setDrawColor(0);
            u8g2.setFont(u8g2_font_unifont_t_japanese1);
            u8g2.drawUTF8(0, 16, "フォルダを選ぶ");

            u8g2.setDrawColor(1);

            if (fileIndex < fileScroll) fileScroll = fileIndex;
            if (fileIndex >= fileScroll + DISPLAY_LINES) fileScroll = fileIndex - DISPLAY_LINES + 1;

            for (int i = 0; i < DISPLAY_LINES && (i + fileScroll) < fileCount; i++) {
              int idx = i + fileScroll;
              int y = 33 + i * 14;
              if (idx == fileIndex) u8g2.drawFrame(0, y - 12, 256, 14);
              u8g2.drawUTF8(2, y, fileList[idx].c_str());
            }
          }

          // -------- CSV閲覧 --------
          else if (viewState == VIEW_CSV) {
            u8g2.setDrawColor(1);
            u8g2.drawBox(0, 0, 258, 20);

            u8g2.setDrawColor(0);
            u8g2.setFont(u8g2_font_unifont_t_japanese1);
            u8g2.drawUTF8(0, 16, "ラップタイム");

            u8g2.setDrawColor(1);

            // スクロール調整
            if (csvIndex < csvScroll) csvScroll = csvIndex;
            if (csvIndex >= csvScroll + DISPLAY_LINES - 1) csvScroll = csvIndex - (DISPLAY_LINES - 1) + 1;

            // ラップ表示
            for (int i = 0; i < DISPLAY_LINES - 1  && (i + csvScroll) < lapCount; i++) {
              int idx = i + csvScroll;
              int y = 33 + i * 14;
              if (idx == csvIndex) u8g2.drawFrame(0, y + 2, 256, 14);

              // CSV形式: lap,lapTime,bestTime
              int firstComma = laps[idx].indexOf(",");
              int secondComma = laps[idx].indexOf(",", firstComma + 1);

              String lapStr = laps[idx].substring(0, firstComma);
              String lapTimeStr = laps[idx].substring(firstComma + 1, secondComma);
              String bestTimeStr = laps[idx].substring(secondComma + 1);

              String displayStr = lapTimeStr + " (" + bestTimeStr + ")";

              // 右寄せ LAP番号を幅100pxの範囲で表示
              int maxLapWidth = 25;  // LAP番号部分の幅
              int lapNumberWidth = u8g2.getUTF8Width(lapStr.c_str());
              int lapX = maxLapWidth - lapNumberWidth;  // 右寄せの x 座標

              // LAP番号表示
              u8g2.drawUTF8(lapX, y + 14, lapStr.c_str());
              // 残りのタイムとベストタイムは固定位置
              u8g2.drawUTF8(maxLapWidth + 5, y + 14, displayStr.c_str());

              // ヘッダ表示
              u8g2.drawUTF8(1, 34, "LAP  TIME      BEST     MAX AVG");
            }
          }

          break;
        case SCREEN_TRACK: 
          if(trackState == TRACK_MENU){
            u8g2.clearBuffer();
            u8g2.setDrawColor(1);
            u8g2.drawBox(0, 0, 258, 20);

            u8g2.setDrawColor(0);
            u8g2.setFont(u8g2_font_unifont_t_japanese1);
            u8g2.drawUTF8(0, 16, "トラックを選らぶ");

            u8g2.setDrawColor(1);
            u8g2.drawUTF8(5, 45, "近くのサーキットを探す");
            u8g2.drawUTF8(5, 75, "保存したサーキット");
            u8g2.drawUTF8(5, 105, "スタートラインの作成");
            if(selectTrack == 0){
              u8g2.drawFrame(3, 30, 200, 18);
            }else if(selectTrack == 1){
              u8g2.drawFrame(3, 60, 200, 18);
            }else if(selectTrack == 2){
              u8g2.drawFrame(3, 90, 200, 18);
            }
            //下のバーについて
            Underber();
            u8g2.setDrawColor(0);
            u8g2.drawUTF8(1, 125, "GPS");
            drawGPSSignal(gps.hdop.hdop(), 2, 2, 1, 30, 125);
            u8g2.setDrawColor(1);
          }
          if(trackState == TRACK_GPS){
            u8g2.clearBuffer();
            u8g2.setDrawColor(1);
            u8g2.drawBox(0, 0, 258, 20);

            u8g2.setDrawColor(0);
            u8g2.setFont(u8g2_font_unifont_t_japanese1);
            u8g2.drawUTF8(0, 16, "近くのサーキットを探す");
            u8g2.setDrawColor(1);
            if(gps.hdop.hdop() < 5.0){
            //近くのサーキットを探す関数の呼び出しで配列の何列目かが分かるようになる
              int nearf = findNearestCircuit(gps.location.lng(), gps.location.lat());
              u8g2.drawUTF8(2, 45, circuits[nearf][0].c_str());
              u8g2.drawLine(0, 50, 256, 50);
              u8g2.drawUTF8(2, 67, "が見つかりました");
              u8g2.drawUTF8(43, 92, "レコードラインに設定");
              u8g2.drawFrame(40, 75, 170, 21);
              if (showMessage){
                if (millis() - lastButtonPress < 2000) {
                  u8g2.setDrawColor(1);
                  u8g2.drawBox(40, 24, 180, 88);
                  u8g2.setDrawColor(0);
                  u8g2.drawUTF8(45, 73, "設定しました");
                  u8g2.setDrawColor(1);
                } else {
                  showMessage = false;
                }
              }
            } else {
              u8g2.drawUTF8(2, 50, "探しています ...");
            }
            //下のバーについて
            Underber();
            u8g2.setDrawColor(0);
            u8g2.drawUTF8(1, 125, "GPS");
            drawGPSSignal(gps.hdop.hdop(), 2, 2, 1, 30, 125);
            u8g2.setDrawColor(1);
          }
          if(trackState == TRACK_SAVE){
            u8g2.clearBuffer();
            u8g2.setDrawColor(1);
            u8g2.drawBox(0, 0, 258, 20);

            u8g2.setDrawColor(0);
            u8g2.setFont(u8g2_font_unifont_t_japanese3);
            u8g2.drawUTF8(0, 16, "保存したサーキット");
            u8g2.setDrawColor(1);

            int circuitScroll = updateScroll(circuitIndex, 6);
            for (int i = 0; i < 6 && (i + circuitScroll) < circuitCount; i++) {
              int idx = i + circuitScroll;
              int y = 35 + i * 18;
              if (idx == circuitIndex) u8g2.drawFrame(0, y - 15, 256, 18);

              u8g2.drawUTF8(2, y, circuits[idx][0].c_str());
            }

            if(viewstate == true){
              u8g2.drawBox(40, 24, 180, 88);
              u8g2.setDrawColor(0);
              u8g2.setFont(u8g2_font_unifont_t_japanese2);
              u8g2.drawUTF8(45, 43, "レコードラインに設定");
              u8g2.drawUTF8(45, 73, "詳細を見る");
              u8g2.drawUTF8(45, 103, "ベストタイムを削除");
              if(viewstateframe == 0){
                u8g2.drawFrame(45, 27, 170, 21);
              }else if(viewstateframe == 1){
                u8g2.drawFrame(45, 57, 170, 21);
              }else if(viewstateframe == 2){
                u8g2.drawFrame(45, 87, 170, 21);
              }
              u8g2.setDrawColor(1);
            }
            if (showMessage){
              if (millis() - lastButtonPress < 2000) {
                u8g2.setDrawColor(1);
                u8g2.drawBox(40, 24, 180, 88);
                u8g2.setDrawColor(0);
                u8g2.drawUTF8(45, 73, "設定しました");
              } else {
                showMessage = false;
              }
            }
            if(showdetail){
              u8g2.clearBuffer();
              u8g2.setDrawColor(1);
              u8g2.drawBox(0, 0, 258, 20);
              u8g2.drawBox(2, 73, 120, 23);
              u8g2.drawFrame(2, 36, 120, 22);
              u8g2.drawFrame(2, 75, 120, 45);
              u8g2.setDrawColor(0);
              u8g2.setFont(u8g2_font_unifont_t_japanese3);
              u8g2.drawUTF8(0, 16, circuits[circuitIndex][0].c_str());
              u8g2.drawUTF8(2, 90, "全長");
              u8g2.setDrawColor(1);
              u8g2.drawUTF8(2, 35, "ベストタイム");
              u8g2.setFont(u8g2_font_luBS14_tr);
              u8g2.drawUTF8(10, 115, circuits[circuitIndex][5].c_str());
              u8g2.drawUTF8(95, 115, "m");
              u8g2.drawStr(12, 55, formatTime(circuits[circuitIndex][6].toInt()).c_str());
              drawMiniMap();
            }
            if(showdeleat){
              u8g2.setDrawColor(1);
              u8g2.drawBox(40, 24, 180, 88);
              u8g2.setDrawColor(0);
              u8g2.drawUTF8(55, 53, "本当に削除しますか");
              u8g2.drawFrame(106, 73, 40, 21);
              u8g2.drawUTF8(110, 88, "決定");
            }
            u8g2.setFont(u8g2_font_unifont_t_japanese1);
          }
          if(trackState == TRACK_MAKE){
            u8g2.clearBuffer();
            u8g2.setDrawColor(1);
            u8g2.drawBox(0, 0, 258, 20);

            u8g2.setDrawColor(0);
            u8g2.setFont(u8g2_font_unifont_t_japanese1);
            u8g2.drawUTF8(0, 16, "スタートラインの作成");
            u8g2.setDrawColor(1);
            if (firstpoint == false){
              u8g2.drawUTF8(0, 32, "レコードラインを作るため2点を取ります");
              u8g2.drawUTF8(0, 48, "初めに点Aを取ります");
            } else if (firstpoint){
              u8g2.drawUTF8(0, 32, "レコードラインを作るため2点を取ります");
              u8g2.drawUTF8(0, 48, "最後に点Bを取ります");
            }
            if (showMessage){
              if (millis() - lastButtonPress < 2000) {
                u8g2.setDrawColor(1);
                u8g2.drawBox(40, 24, 180, 88);
                u8g2.setDrawColor(0);
                u8g2.drawUTF8(45, 73, "設定しました");
              } else {
                showMessage = false;
                trackState = TRACK_MENU;
                firstpoint = false;
              }
            }
            //下のバーについて
            u8g2.setDrawColor(1);
            Underber();
            u8g2.setDrawColor(0);
            u8g2.drawUTF8(1, 125, "GPS");
            drawGPSSignal(gps.hdop.hdop(), 2, 2, 1, 30, 125);
            u8g2.setDrawColor(1);
          }
          break;
        case SCREEN_GPS:
          //ヘッダーの作成
          u8g2.clearBuffer();
          u8g2.setDrawColor(1);
          u8g2.drawBox(0, 0, 258, 20);
          u8g2.setDrawColor(0);
          u8g2.setFont(u8g2_font_unifont_t_japanese1);
          u8g2.drawUTF8(0, 16, "GPS情報");
          u8g2.setDrawColor(1);

          if (gps.date.isValid() && gps.time.isValid()) {
            int hourJST = (gps.time.hour() + 9) % 24;
            char day[20];
            sprintf(day, "%04d/%02d/%02d", gps.date.year(), gps.date.month(), gps.date.day());
            u8g2.drawUTF8(1, 32, day);

            char time[20];
            sprintf(time, "%02d:%02d:%02d", hourJST, gps.time.minute(), gps.time.second());
            u8g2.drawUTF8(128, 32, time);
            u8g2.drawFrame(0, 17, 256, 18);
          }
          u8g2.setFont(u8g2_font_unifont_t_japanese2);
          char lat[32];
          sprintf(lat, "緯度:%.6f", gps.location.lat());
          char lng[32];
          sprintf(lng, "経度:%.6f", gps.location.lng());
          char alt[32];
          sprintf(alt, "高度:%.1f m", gps.altitude.meters());
          char sat[16];
          sprintf(sat, "衛星数:%d", gps.satellites.value());
          u8g2.drawUTF8(0, 50, lat);
          u8g2.drawUTF8(0, 65, lng);
          u8g2.drawUTF8(0, 81, alt);
          u8g2.drawUTF8(0, 98, sat);
          //下のバーについて
          Underber();
          u8g2.setDrawColor(0);
          u8g2.drawUTF8(1, 125, "GPS");
          drawGPSSignal(gps.hdop.hdop(), 2, 2, 1, 30, 125);
          u8g2.setDrawColor(1);
          break;
        case SCREEN_WIFI:
        //ヘッダーの作成
          u8g2.clearBuffer();
          u8g2.setDrawColor(1);
          u8g2.drawBox(0, 0, 258, 20);
          u8g2.setDrawColor(0);
          u8g2.setFont(u8g2_font_unifont_t_japanese1);
          u8g2.drawUTF8(0, 16, "ファームウェア画面");
          u8g2.setDrawColor(1);
          u8g2.drawUTF8(5, 45, "ラップタイマーアップデート");
          u8g2.drawUTF8(5, 75, "GPSデータログのアップロード");
          u8g2.drawUTF8(5, 105, "記録やトラックの編集");
          if(selectgps == 0){
            u8g2.drawFrame(3, 30, 200, 18);
          }else if(selectgps == 1){
            u8g2.drawFrame(3, 60, 200, 18);
          }else if(selectgps == 2){
            u8g2.drawFrame(3, 90, 200, 18);
          }
          if(selectGPS){
            u8g2.clearBuffer();
            if(selectgps == 0){
              u8g2.drawUTF8(5, 75, "アップデート画面");
            }else if(selectgps == 1){
              u8g2.drawUTF8(5, 75, "アップロード画面");
            }else if(selectgps == 2){
              u8g2.drawUTF8(5, 75, "編集画面");
            }
          }
          Underber();
          u8g2.setDrawColor(0);
          u8g2.drawUTF8(1, 125, "GPS");
          drawGPSSignal(gps.hdop.hdop(), 2, 2, 1, 30, 125);
          u8g2.setDrawColor(1);
        break;
        case SCREEN_SETTING:
          u8g2.setFont(u8g2_font_6x10_tr);
          u8g2.drawUTF8(0, 10, "設定メニュー");
          Underber();
          u8g2.setDrawColor(0);
          u8g2.drawUTF8(1, 125, "GPS");
          drawGPSSignal(gps.hdop.hdop(), 2, 2, 1, 30, 125);
          u8g2.setDrawColor(1);
          break;
      }
    }
  } while (u8g2.nextPage());
}